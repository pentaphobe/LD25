package com.mutantamoeba.ld25.actors;

import com.badlogic.gdx.Gdx;
import com.badlogic.gdx.graphics.g2d.BitmapFont;
import com.badlogic.gdx.graphics.g2d.SpriteBatch;
import com.badlogic.gdx.scenes.scene2d.Actor;
import com.badlogic.gdx.scenes.scene2d.InputEvent;
import com.badlogic.gdx.scenes.scene2d.utils.ClickListener;
import com.mutantamoeba.ld25.engine.Console;
import com.mutantamoeba.ld25.screens.GameScreen;

public class FpsCounter extends Actor {
	GameScreen gameScreen;
	public FpsCounter(GameScreen gameScreen) {
		super();
		this.gameScreen = gameScreen;
		this.setSize(30, 10);
		addListener(new ClickListener() {
			/* (non-Javadoc)
			 * @see com.badlogic.gdx.scenes.scene2d.utils.ClickListener#clicked(com.badlogic.gdx.scenes.scene2d.InputEvent, float, float)
			 */
			@Override
			public void clicked(InputEvent event, float x, float y) {
				Console.debug("Clicked FpsCounter");
				super.clicked(event, x, y);
			}				
		});
	}
	/* (non-Javadoc)
	 * @see com.badlogic.gdx.scenes.scene2d.Actor#draw(com.badlogic.gdx.graphics.g2d.SpriteBatch, float)
	 */
	@Override
	public void draw(SpriteBatch batch, float parentAlpha) {
		// TODO Auto-generated method stub
		BitmapFont fnt = gameScreen.getFont();				
		
		fnt.draw(batch, 
				String.format("FPS:%d", Gdx.graphics.getFramesPerSecond()), getX(), getY());
		
	}

	/* (non-Javadoc)
	 * @see com.badlogic.gdx.scenes.scene2d.Actor#act(float)
	 */
	@Override
	public void act(float delta) {
		// TODO Auto-generated method stub
		super.act(delta);
	}

}	package com.mutantamoeba.ld25.engine;

import com.badlogic.gdx.InputProcessor;

public abstract class BasicInputProcessor implements InputProcessor {

	@Override
	public boolean keyDown(int keycode) {
		// TODO Auto-generated method stub
		return false;
	}

	@Override
	public boolean keyUp(int keycode) {
		// TODO Auto-generated method stub
		return false;
	}

	@Override
	public boolean keyTyped(char character) {
		// TODO Auto-generated method stub
		return false;
	}

	@Override
	public boolean touchDown(int x, int y, int pointer, int button) {
		// TODO Auto-generated method stub
		return false;
	}

	@Override
	public boolean touchUp(int x, int y, int pointer, int button) {
		// TODO Auto-generated method stub
		return false;
	}

	@Override
	public boolean touchDragged(int x, int y, int pointer) {
		// TODO Auto-generated method stub
		return false;
	}

	@Override
	public boolean mouseMoved(int x, int y) {
		// TODO Auto-generated method stub
		return false;
	}

	@Override
	public boolean scrolled(int amount) {
		// TODO Auto-generated method stub
		return false;
	}

}
package com.mutantamoeba.ld25.engine;

import com.badlogic.gdx.Game;
import com.badlogic.gdx.Gdx;
import com.mutantamoeba.ld25.LD25;

/** Just a basic wrapper for console stuff
 * @author keili
 *
 */
public class Console {
	public static void log(String fmt, Object... args) {
		Gdx.app.log(LD25.LOG, String.format(fmt, args));
	}
	public static void debug(String fmt, Object... args) {
		if (LD25.DEBUG_MODE) { 
			Gdx.app.debug(LD25.LOG, String.format(fmt, args));			
		}
	}
}
package com.mutantamoeba.ld25;

import com.mutantamoeba.ld25.screens.GameScreen;

public class GameWorld {
	public static final int ROOM_SIZE = 5;
	public int mapWidth, mapHeight;
	public int tileMapWidth, tileMapHeight;

	RoomMap roomMap;
	TileMap tileMap;
	GameScreen gameScreen;
	
	public GameWorld(GameScreen gameScreen, int mapWidth, int mapHeight) {
		this.gameScreen = gameScreen;
		this.mapWidth = mapWidth;
		this.mapHeight = mapHeight;
		roomMap = new RoomMap(mapWidth, mapHeight);
		this.tileMapWidth = mapWidth * ROOM_SIZE;
		this.tileMapHeight = mapHeight * ROOM_SIZE;
		tileMap = new TileMap(this.tileMapWidth, this.tileMapHeight);
	}
}
package com.mutantamoeba.ld25;

import com.badlogic.gdx.Game;
import com.badlogic.gdx.Gdx;
import com.mutantamoeba.ld25.engine.Console;
import com.mutantamoeba.ld25.screens.GameScreen;

public class LD25 extends Game {
	public static final boolean DEBUG_MODE = true;
	public static final String VERSION = "0.0.1";
	public static final String LOG = "LD25: ";
			
	@Override
	public void create() {	
		Gdx.app.setLogLevel(Gdx.app.LOG_DEBUG);
		Console.debug("create");
//		if (DEBUG_MODE) {
			// skip the splash screen if we're in debug mode
//			setScreen(new MainMenu(this));
//		} else {
//			setScreen(new SplashScreen(this));		
//		}	
		setScreen(new GameScreen(this));
	}
	
	@Override
	public void dispose() {
		Console.debug("got to dispose");
		super.dispose();
	}
	
	
}
package com.mutantamoeba.ld25;

public class Room {

}
package com.mutantamoeba.ld25;

import com.mutantamoeba.ld25.utils.ParameterMap;


public class RoomMap extends ParameterMap<Room> {
	public RoomMap(int w, int h) {
		super("rooms", w, h, null);
	}
}
package com.mutantamoeba.ld25.screens;


import com.badlogic.gdx.Game;
import com.badlogic.gdx.Screen;
import com.mutantamoeba.ld25.engine.BasicInputProcessor;

public abstract class AbstractScreen extends BasicInputProcessor implements Screen {
	protected final Game game;
	
	public AbstractScreen(Game game) {
		this.game = game;
	}

}
package com.mutantamoeba.ld25.screens;

import com.badlogic.gdx.Game;
import com.badlogic.gdx.Gdx;
import com.badlogic.gdx.Input;
import com.badlogic.gdx.graphics.GL10;
import com.badlogic.gdx.graphics.g2d.BitmapFont;
import com.badlogic.gdx.scenes.scene2d.Stage;

public abstract class BasicScreen extends AbstractScreen {
	protected Stage stage;
	private BitmapFont font;	
	
	public BasicScreen(Game game) {
		super(game);
		stage = new Stage( Gdx.graphics.getWidth(), Gdx.graphics.getHeight(), true);
		stage.getSpriteBatch().getProjectionMatrix().scl(1, -1, 1);
		Gdx.input.setInputProcessor(this);
		
	}

	
	public BitmapFont getFont() {
		if (font == null) {
			font = new BitmapFont(Gdx.files.internal("skin/default.fnt"), false);
		}
		return font;
	}
	
	public Stage getStage() {
		return stage;
	}
	
	@Override
	public void render(float delta) {		
		stage.act(delta);
		
		Gdx.gl.glClearColor(0,0,0,1);
		Gdx.gl.glClear(GL10.GL_COLOR_BUFFER_BIT);
		
		stage.draw();

	}

	@Override
	public void resize(int width, int height) {
		stage.setViewport(width, height, true);			
	}

	@Override
	public void dispose() {
		font.dispose();
		stage.dispose();
	}

	public void toggleFullscreen() {
		if (Gdx.graphics.isFullscreen()) {
			Gdx.graphics.setDisplayMode(Gdx.graphics.getWidth(), Gdx.graphics.getHeight(), true);
		} else {
			Gdx.graphics.setDisplayMode(Gdx.graphics.getWidth(), Gdx.graphics.getHeight(), false);
		}
		resize(Gdx.graphics.getWidth(), Gdx.graphics.getHeight());
	}	
	
	@Override
	public void show() {
		// TODO Auto-generated method stub		
	}

	@Override
	public void hide() {
		// TODO Auto-generated method stub
		
	}

	@Override
	public void pause() {
		// TODO Auto-generated method stub
		
	}

	@Override
	public void resume() {
		// TODO Auto-generated method stub
		
	}


	/* (non-Javadoc)
	 * @see com.mutantamoeba.ld25.engine.BasicInputProcessor#keyDown(int)
	 */
	@Override
	public boolean keyDown(int keycode) {
		return stage.keyDown(keycode);
	}


	/* (non-Javadoc)
	 * @see com.mutantamoeba.ld25.engine.BasicInputProcessor#keyUp(int)
	 */
	@Override
	public boolean keyUp(int keycode) {
		if (keycode == Input.Keys.F11) {
			toggleFullscreen();
		}
		return stage.keyUp(keycode);
	}


	/* (non-Javadoc)
	 * @see com.mutantamoeba.ld25.engine.BasicInputProcessor#keyTyped(char)
	 */
	@Override
	public boolean keyTyped(char character) {
		return stage.keyTyped(character);
	}


	/* (non-Javadoc)
	 * @see com.mutantamoeba.ld25.engine.BasicInputProcessor#touchDown(int, int, int, int)
	 */
	@Override
	public boolean touchDown(int x, int y, int pointer, int button) {
		return stage.touchDown(x, y, pointer, button);
	}


	/* (non-Javadoc)
	 * @see com.mutantamoeba.ld25.engine.BasicInputProcessor#touchUp(int, int, int, int)
	 */
	@Override
	public boolean touchUp(int x, int y, int pointer, int button) {
		return stage.touchUp(x, y, pointer, button);
	}


	/* (non-Javadoc)
	 * @see com.mutantamoeba.ld25.engine.BasicInputProcessor#touchDragged(int, int, int)
	 */
	@Override
	public boolean touchDragged(int x, int y, int pointer) {		
		return stage.touchDragged(x, y, pointer);
	}


	/* (non-Javadoc)
	 * @see com.mutantamoeba.ld25.engine.BasicInputProcessor#mouseMoved(int, int)
	 */
	@Override
	public boolean mouseMoved(int x, int y) {
		return stage.mouseMoved(x, y);
	}


	/* (non-Javadoc)
	 * @see com.mutantamoeba.ld25.engine.BasicInputProcessor#scrolled(int)
	 */
	@Override
	public boolean scrolled(int amount) {
		return stage.scrolled(amount);
	}


}
package com.mutantamoeba.ld25.screens;

import com.badlogic.gdx.Game;
import com.badlogic.gdx.Gdx;
import com.badlogic.gdx.Input;
import com.badlogic.gdx.graphics.GL10;
import com.badlogic.gdx.graphics.OrthographicCamera;
import com.badlogic.gdx.graphics.Texture;
import com.badlogic.gdx.graphics.Texture.TextureFilter;
import com.badlogic.gdx.graphics.Texture.TextureWrap;
import com.badlogic.gdx.scenes.scene2d.Actor;
import com.badlogic.gdx.scenes.scene2d.InputEvent;
import com.badlogic.gdx.scenes.scene2d.Stage;
import com.badlogic.gdx.scenes.scene2d.utils.ClickListener;
import com.mutantamoeba.ld25.GameWorld;
import com.mutantamoeba.ld25.actors.FpsCounter;
import com.mutantamoeba.ld25.engine.Console;

public class GameScreen extends BasicScreen {
	static final int WORLD_WIDTH = 16;
	static final int WORLD_HEIGHT = 16;
	static final int TILE_SIZE = 32;
	static final float SCROLL_SPEED = 200f; // pixels per second
	static final float SCROLL_FAST_MULTIPLIER = 3f; // how much faster than SCROLL_SPEED do we go in fast mode?
	
	Texture texture;
	boolean showFPS = true;
	Stage uiStage;
	GameWorld world;
	RoomRenderer roomRenderer;
	TileRenderer tileRenderer;
	GameTileset gameTiles;

	public GameScreen(Game game) {
		super(game);
		texture = new Texture("data/tiles.png");
		texture.setFilter(TextureFilter.Nearest, TextureFilter.Nearest);
		texture.setWrap(TextureWrap.ClampToEdge, TextureWrap.ClampToEdge);
		gameTiles = new GameTileset(texture, 32);
		
		gameTiles.addSubset("walls", TileSubset.Type.NINEPATCH, 0, 1, 2, 8, 9, 10, 16, 17, 18);
		gameTiles.addSubset("blank", TileSubset.Type.SINGLE, 27);
		gameTiles.addSubset("floor", TileSubset.Type.SINGLE, 24);
		
		
		uiStage = new Stage( Gdx.graphics.getWidth(), Gdx.graphics.getHeight(), true);
		uiStage.getSpriteBatch().getTransformMatrix().scale(1, -1, 1);
		Actor fpsCounter = new FpsCounter(this);
		fpsCounter.setPosition(10, 20);
		uiStage.addActor(fpsCounter);	
		
		world = new GameWorld(this, WORLD_WIDTH, WORLD_HEIGHT);
		
		tileRenderer = new TileRenderer(world, gameTiles);
		stage.addActor(tileRenderer);
		
		roomRenderer = new RoomRenderer(world);
		roomRenderer.addListener(new ClickListener() {
			/* (non-Javadoc)
			 * @see com.badlogic.gdx.scenes.scene2d.InputListener#touchDown(com.badlogic.gdx.scenes.scene2d.InputEvent, float, float, int, int)
			 */
			@Override
			public void clicked(InputEvent event, float x, float y) {				
				Console.debug("roomRenderer touched at %f, %f", x, y);
				super.clicked(event, x, y);
			}
			
		});
		stage.addActor(roomRenderer);
		
	}

	/* (non-Javadoc)
	 * @see com.mutantamoeba.ld25.screens.BasicScreen#render(float)
	 */
	@Override
	public void render(float delta) {
		Gdx.gl.glClearColor(0,0,0,1);
		Gdx.gl.glClear(GL10.GL_COLOR_BUFFER_BIT);
		
		update(delta);
		
		stage.draw();			
		uiStage.draw();		
	}
	
	public void update(float delta) {
		OrthographicCamera cam = (OrthographicCamera)stage.getCamera();
		float moveX = 0;
		float moveY = 0;
		float scrollSpeed = SCROLL_SPEED * delta;
		if (Gdx.input.isKeyPressed(Input.Keys.SHIFT_LEFT)) {
			scrollSpeed *= SCROLL_FAST_MULTIPLIER;
		}
		if (Gdx.input.isKeyPressed(Input.Keys.A)) {
			moveX -= scrollSpeed * cam.zoom;
		} 
		if (Gdx.input.isKeyPressed(Input.Keys.D)) {
			moveX += scrollSpeed * cam.zoom;
		} 
		if (Gdx.input.isKeyPressed(Input.Keys.W)) {
			moveY += scrollSpeed * cam.zoom;
		} 
		if (Gdx.input.isKeyPressed(Input.Keys.S)) {
			moveY -= scrollSpeed * cam.zoom;
		} 
		cam.translate(moveX, moveY);
		
		stage.act(delta);
		uiStage.act(delta);
	}
	
	/* (non-Javadoc)
	 * @see com.mutantamoeba.ld25.screens.BasicScreen#dispose()
	 */
	@Override
	public void dispose() {
		texture.dispose();
		super.dispose();
	}
	
	/* (non-Javadoc)
	 * @see com.mutantamoeba.ld25.screens.BasicScreen#scrolled(int)
	 */
	@Override
	public boolean scrolled(int amount) {
//		Console.debug("SCROLLED:%d", amount);
		OrthographicCamera cam = (OrthographicCamera)stage.getCamera(); 
		cam.zoom += amount / 10.0f;
		float minZoom = 0.1f;
		float maxZoom = 10;
		if (cam.zoom < minZoom) {
			cam.zoom = minZoom;
		} else if (cam.zoom > maxZoom) {
			cam.zoom = maxZoom;
		}
		return super.scrolled(amount);
	}
	
	/* (non-Javadoc)
	 * @see com.mutantamoeba.ld25.engine.BasicInputProcessor#touchDown(int, int, int, int)
	 */
	@Override
	public  boolean touchDown(int x, int y, int pointer, int button) {
		if (uiStage.touchDown(x, y, pointer, button)) {
			return true;
		}
		Console.debug("touchdown %d, %d", x, y);
		
		return super.touchDown(x, y, pointer, button);
	}


	/* (non-Javadoc)
	 * @see com.mutantamoeba.ld25.engine.BasicInputProcessor#touchUp(int, int, int, int)
	 */
	@Override
	public boolean touchUp(int x, int y, int pointer, int button) {
		if (uiStage.touchUp(x, y, pointer, button)) {
			return true;
		}
		return super.touchUp(x, y, pointer, button);
	}


	/* (non-Javadoc)
	 * @see com.mutantamoeba.ld25.engine.BasicInputProcessor#touchDragged(int, int, int)
	 */
	@Override
	public boolean touchDragged(int x, int y, int pointer) {

		if (uiStage.touchDragged(x, y, pointer)) {
			return true;
		}
		Console.debug("dragged");		
		return stage.touchDragged(x, y, pointer);
	}		
}
package com.mutantamoeba.ld25.screens;

import com.badlogic.gdx.graphics.Texture;
import com.badlogic.gdx.utils.Array;
import com.badlogic.gdx.utils.ObjectMap;
import com.mutantamoeba.ld25.engine.Console;

public class GameTileset {
	Texture texture;
	int		tileSize;
	ObjectMap<String, Integer>	setNameToIndex = new ObjectMap<String, Integer>();
	Array<TileSubset> tileSubsets = new Array<TileSubset>();
	
	public GameTileset(Texture texture, int tileSize) {
		 this.texture = texture;
		 this.tileSize = tileSize;
	}

	public TileSubset addSubset(String name, TileSubset.Type type, int ...tileIndices) {
		TileSubset set;
		switch (type) {
		case SINGLE:
			set = TileSubset.createSingle(tileIndices[0]);
			break;
		case MULTI:
			set = TileSubset.createMulti(tileIndices);
			break;
		case NINEPATCH:
			set = TileSubset.createNinePatch(tileIndices);
			break;
		default:
			Console.debug("definition of %s [%s] contains an unknown type: %s", name, tileIndices, type);
			return null;
		}
		
		int idx = tileSubsets.size;
		setNameToIndex.put(name, idx);
		tileSubsets.add(set);
		return set;
	}
}
package com.mutantamoeba.ld25.screens;

import com.badlogic.gdx.Gdx;
import com.badlogic.gdx.graphics.GL10;
import com.badlogic.gdx.graphics.GL11;
import com.badlogic.gdx.graphics.GL20;
import com.badlogic.gdx.graphics.g2d.SpriteBatch;
import com.badlogic.gdx.graphics.glutils.ImmediateModeRenderer;
import com.badlogic.gdx.graphics.glutils.ImmediateModeRenderer10;
import com.badlogic.gdx.graphics.glutils.ImmediateModeRenderer20;
import com.badlogic.gdx.scenes.scene2d.Actor;
import com.mutantamoeba.ld25.GameWorld;
import com.mutantamoeba.ld25.engine.Console;

public class RoomRenderer extends Actor {
	ImmediateModeRenderer debugRenderer;
	GameWorld world;
	public RoomRenderer(GameWorld world) {
		super(); 
		setSize(world.mapWidth * world.ROOM_SIZE, world.mapHeight * world.ROOM_SIZE);
		this.world = world;
		if (Gdx.graphics.isGL20Available())
			debugRenderer = new ImmediateModeRenderer20(64, false, true, 0);
		else
			debugRenderer = new ImmediateModeRenderer10(64);
	}
	
	@Override
	public void draw(SpriteBatch batch, float delta) {
		// TEMPORARY
				
		debugRenderer.begin(batch.getProjectionMatrix(), GL10.GL_LINES);
		debugRenderer.color(1, 0, 1, 0.5f);
		int roomSizeInTiles = GameScreen.TILE_SIZE * world.ROOM_SIZE;
		
		for (int y=0;y<world.mapWidth;y++) {
			float ry = y * roomSizeInTiles;
			for (int x=0;x<world.mapHeight;x++) {
				float rx = x * roomSizeInTiles;
				debugRenderer.vertex(rx, ry, 0);
				debugRenderer.vertex(rx, ry+roomSizeInTiles, 0);
				
				debugRenderer.vertex(rx, ry+roomSizeInTiles, 0);
				debugRenderer.vertex(rx+roomSizeInTiles, ry+roomSizeInTiles, 0);
				
				debugRenderer.vertex(rx+roomSizeInTiles, ry+roomSizeInTiles, 0);
				debugRenderer.vertex(rx+roomSizeInTiles, ry, 0);
				
				debugRenderer.vertex(rx+roomSizeInTiles, ry, 0);
				debugRenderer.vertex(rx, ry, 0);
								
				if (debugRenderer.getNumVertices() == 64) {
					debugRenderer.end();
					debugRenderer.begin(batch.getProjectionMatrix(), GL10.GL_LINES);					
				}
			}
		}
		debugRenderer.end();
		// END TEMPORARY		
	}

	/* (non-Javadoc)
	 * @see com.badlogic.gdx.scenes.scene2d.Actor#act(float)
	 */
	@Override
	public void act(float delta) {
		
		super.act(delta);
	}
}
package com.mutantamoeba.ld25.screens;

import java.util.Random;

import com.badlogic.gdx.Game;
import com.badlogic.gdx.Gdx;
import com.badlogic.gdx.graphics.Color;
import com.badlogic.gdx.graphics.OrthographicCamera;
import com.badlogic.gdx.graphics.g2d.SpriteBatch;
import com.badlogic.gdx.scenes.scene2d.Actor;
import com.badlogic.gdx.scenes.scene2d.Event;
import com.mutantamoeba.ld25.engine.Console;

public class TestScreen extends BasicScreen {
	static Random rand = new Random();	
	public TestScreen(Game game) {
		super(game);
		
	}

	public class TestActor extends Actor {
		private float angle;
		private Color color;
		private boolean noMove = false;
		private int UID = rand.nextInt();
		public TestActor() {
			super();			
			angle = rand.nextInt(200) - 100;
			color = new Color(rand.nextFloat(), rand.nextFloat(), rand.nextFloat(), 1);
			this.setSize(40f, 30f);
			
		}
		@Override
		public void draw(SpriteBatch batch, float parentAlpha) {
			// TODO Auto-generated method stub
			super.draw(batch, parentAlpha);
			getFont().setColor(color);
			getFont().draw(getStage().getSpriteBatch(), "hello", getX(), getY());						
		}

		@Override
		public void act(float delta) {
			// TODO Auto-generated method stub
			super.act(delta);
			updatePosition();
			angle += delta * 5.0f;
		}
		
		public void updatePosition() {
			this.setPosition(Gdx.graphics.getWidth() / 2.0f + 200f * ((float)Math.sin(angle / 7f) + (float)Math.cos(angle / 13f)), 
					Gdx.graphics.getHeight() / 2.0f + 100f * ((float)Math.cos(angle / 3f) + (float)Math.sin(angle / 17f)));

		}

		@Override
		public boolean fire(Event event) {
			// TODO Auto-generated method stub
//			Console.debug("%s fire:%s", this, event);
			return super.fire(event);
			
		}

		@Override
		public boolean notify(Event event, boolean capture) {
			// TODO Auto-generated method stub			
//			Console.debug("%s notify:%s", this, event);							
			return super.notify(event, capture);
		}

		@Override
		public Actor hit(float x, float y, boolean touchable) {
			// TODO Auto-generated method stub
//			Console.debug("hit:%f, %f, %s", x, y, touchable ? "true" : "false");							
			return super.hit(x, y, touchable);
		}	
		
		@Override
		public String toString() {
			return String.format("TestActor[%d]", UID);
		}
	}
	
	@Override
	public void resize(int width, int height) {
		super.resize(width, height);
		for (int i=0;i<50;i++) 
			getStage().addActor(new TestActor());
	}

	@Override
	public boolean touchDown(int x, int y, int pointer, int button) {
		Actor hit = stage.hit(x, y, true);
		Console.debug("touchdown");
		if (hit == null) return false;
		Console.debug("hit actor (%s) at %d,%d", hit, x, y);
		return true;
	}
	
	/* (non-Javadoc)
	 * @see com.mutantamoeba.ld25.engine.BasicInputProcessor#scrolled(int)
	 */
	@Override
	public boolean scrolled(int amount) {
		Console.debug("SCROLLED:%d", amount);
		((OrthographicCamera)stage.getCamera()).zoom += amount / 10.0f;
		return super.scrolled(amount);
	}

}
package com.mutantamoeba.ld25.screens;

import com.badlogic.gdx.scenes.scene2d.Actor;
import com.mutantamoeba.ld25.GameWorld;

public class TileRenderer extends Actor {
	GameWorld world;
	GameTileset tileSet;
	public TileRenderer(GameWorld world, GameTileset tileSet) {
		this.world = world;
		this.tileSet = tileSet;
	}

}
package com.mutantamoeba.ld25.screens;

public class TileSubset {
	public enum Type {
		SINGLE,
		MULTI,
		NINEPATCH
	}
	Type type;
	public TileSubset(Type type) {
		this.type = type;
	}	
	public static TileSubsetSingle createSingle(int idx) {
		return new TileSubsetSingle(idx);
	}
	public static TileSubsetMulti createMulti(int indices[]) {
		return new TileSubsetMulti(indices);
	}
	public static TileSubsetNinePatch createNinePatch(int indices[]) {
		return new TileSubsetNinePatch(indices);
	}
	
}
package com.mutantamoeba.ld25.screens;

import com.mutantamoeba.ld25.screens.TileSubset.Type;

public class TileSubsetMulti extends TileSubset {
	int tileIndices[];
	public TileSubsetMulti(int tileIndices[]) {
		super(Type.MULTI);
		this.tileIndices = tileIndices;
	}
}package com.mutantamoeba.ld25.screens;

public class TileSubsetNinePatch extends TileSubsetMulti {

	public TileSubsetNinePatch(int[] tileIndices) {
		super(tileIndices);
		
	}

}
package com.mutantamoeba.ld25.screens;

import com.mutantamoeba.ld25.screens.TileSubset.Type;

public class TileSubsetSingle extends TileSubset {
	int tileIndex;

	public TileSubsetSingle(int idx) {
		super(Type.SINGLE);
		tileIndex = idx;
	}
}
package com.mutantamoeba.ld25;

public class Tile {

}
package com.mutantamoeba.ld25;

import com.mutantamoeba.ld25.utils.ParameterMap;


public class TileMap extends ParameterMap<Tile> {

	public TileMap(int w, int h) {
		super("tiles", w, h, null);
	}

}
/**
 * 
 */
package com.mutantamoeba.ld25;

import java.util.Random;

import com.badlogic.gdx.Game;
import com.badlogic.gdx.Gdx;
import com.badlogic.gdx.Input;
import com.badlogic.gdx.graphics.GL10;
import com.badlogic.gdx.graphics.GL11;
import com.badlogic.gdx.graphics.OrthographicCamera;
import com.badlogic.gdx.graphics.Texture;
import com.badlogic.gdx.graphics.Texture.TextureFilter;
import com.badlogic.gdx.graphics.Texture.TextureWrap;
import com.badlogic.gdx.graphics.g2d.BitmapFont;
import com.badlogic.gdx.graphics.g2d.SpriteBatch;
import com.badlogic.gdx.graphics.g2d.SpriteCache;
import com.badlogic.gdx.math.Vector2;
import com.badlogic.gdx.scenes.scene2d.Actor;
import com.badlogic.gdx.scenes.scene2d.Event;
import com.badlogic.gdx.scenes.scene2d.InputEvent;
import com.badlogic.gdx.scenes.scene2d.Stage;
import com.badlogic.gdx.scenes.scene2d.utils.ClickListener;
import com.badlogic.gdx.scenes.scene2d.utils.DragListener;
import com.mutantamoeba.ld25.engine.Console;
import com.mutantamoeba.ld25.screens.BasicScreen;

/** The main game screen
 * @author keili
 *
 */
public class TileTestScreen extends BasicScreen {
	SimpleTileMap tileMap;
	static Random rand = new Random();
	Texture texture;
	boolean showFPS = true;
	Stage uiStage;

	public class SimpleTileMap extends Actor {
		static final int TOTAL_LAYERS = 2;
		Texture texture;
		SpriteCache cache;
		int w, h, area;
		int textureTileWidth, textureTileHeight;
		int maxTileIndex;
		int tileSize;
		int theMap[][];
		int cacheID = -1;
		SimpleTileMap(int w, int h, Texture texture) {
			super();
			this.tileSize = 32;
			setSize(w * this.tileSize, h * this.tileSize);
			addListener(new DragListener() {

				/* (non-Javadoc)
				 * @see com.badlogic.gdx.scenes.scene2d.utils.DragListener#drag(com.badlogic.gdx.scenes.scene2d.InputEvent, float, float, int)
				 */
				@Override
				public void drag(InputEvent event, float x, float y, int pointer) {
					beginEdit();
					setTile(x, y, 0, 32);
					endEdit();
					super.drag(event, x, y, pointer);
				}				
			});
			addListener(new ClickListener() {

				/* (non-Javadoc)
				 * @see com.badlogic.gdx.scenes.scene2d.utils.ClickListener#clicked(com.badlogic.gdx.scenes.scene2d.InputEvent, float, float)
				 */
				@Override
				public void clicked(InputEvent event, float x, float y) {
					beginEdit();
					setTile(x, y, 0, 32);
					endEdit();
					super.clicked(event, x, y);
				}
				
			});
			this.w = w;
			this.h = h;
			this.area = this.w * this.h;
			this.theMap = new int[this.area][TOTAL_LAYERS];
			for (int i=0;i<this.area;i++) {
				for (int j=0;j<TOTAL_LAYERS;j++) {
					theMap[i][j] = -1;
				}
			}
			this.texture = texture;
			this.textureTileWidth = this.texture.getWidth() / this.tileSize;
			this.textureTileHeight = this.texture.getHeight() / this.tileSize;
			this.maxTileIndex = this.textureTileWidth * this.textureTileHeight;
			this.cache = new SpriteCache(this.area * TOTAL_LAYERS, true);
			Console.debug("constructed SimpleTileMap:");
			Console.debug("  tiles: %dx%d (area:%d)", this.w, this.h, this.area);
			Console.debug("  texture tile size: %d x %d", this.textureTileWidth, this.textureTileHeight);
			Console.debug("  tileSize: %d", tileSize);
			
		}
		/* (non-Javadoc)
		 * @see com.badlogic.gdx.scenes.scene2d.Actor#draw(com.badlogic.gdx.graphics.g2d.SpriteBatch, float)
		 */
		@Override
		public void draw(SpriteBatch batch, float parentAlpha) {
			cache.setProjectionMatrix(batch.getProjectionMatrix());
//			batch.enableBlending();
//			batch.setBlendFunction(GL11.GL_SRC_ALPHA, GL11.GL_ONE_MINUS_SRC_ALPHA);
			
			cache.begin();
			Gdx.gl.glEnable(GL11.GL_BLEND);
			Gdx.gl.glBlendFunc(GL11.GL_SRC_ALPHA, GL11.GL_ONE_MINUS_SRC_ALPHA);
			cache.draw(cacheID);			
			Gdx.gl.glDisable(GL11.GL_BLEND);
//			batch.disableBlending();
			cache.end();
//			super.draw(batch, parentAlpha);
		}

		/* (non-Javadoc)
		 * @see com.badlogic.gdx.scenes.scene2d.Actor#act(float)
		 */
		@Override
		public void act(float delta) {
			// TODO Auto-generated method stub
			super.act(delta);
		}
		
		public void beginEdit() {
			cache.clear();
			cache.beginCache();			
		}
		public void endEdit() {
			for (int layer = 0; layer < TOTAL_LAYERS; layer++) {
				for (int y=0, offs=0;y<h;y++) {
					int tileY = y * (tileSize);
					for (int x=0;x<w;x++, offs++) {
						int tileX = x * (tileSize);
						int tileIndex = theMap[offs][layer];
						if (tileIndex == -1) {
							continue;
						}
						int texX = tileIndex % textureTileWidth;
						int texY = tileIndex / textureTileWidth;					
						cache.add(texture, tileX, tileY, texX * tileSize, texY * tileSize, texX + tileSize, texY + tileSize);
					}
				}
			}
			cacheID = cache.endCache();
			
		}
		public void setTile(int x, int y, int layer, int tileIndex) {
			if (x < 0 || y < 0 || x >= w || y >= h) return;
			theMap[y * w + x][layer] = tileIndex;
		}
		public void setTile(float x, float y, int layer, int tileIndex) {
			Vector2 pos = new Vector2(x, y);
			pos = this.stageToLocalCoordinates(pos);
			pos.div(tileSize);
			Console.debug("Setting %f, %f [layer:%d] to %d", pos.x, pos.y, layer, tileIndex);

			setTile((int)pos.x, (int)pos.y, layer, tileIndex);
		}
	}
	public TileTestScreen(Game game) {
		super(game);
		
//		texture = new Texture("data/tileTest.png");
		texture = new Texture("data/tileTest.png");
		texture.setFilter(TextureFilter.Nearest, TextureFilter.Nearest);
		texture.setWrap(TextureWrap.ClampToEdge, TextureWrap.ClampToEdge);
				 	
		tileMap = new SimpleTileMap(16, 32, texture);
		int wallTiles[] = new int[] { 0, 1, 2, 8, 9, 10, 16, 17, 18 };
		tileMap.beginEdit();
		for (int i=0;i<tileMap.area;i++) {
			tileMap.theMap[i][0] = 33;
			if (rand.nextInt(100) < 10) {
				int tx = i % tileMap.textureTileWidth;
				int ty = i / tileMap.textureTileWidth;
				int wx = tx % 3;
				int wy = ty % 3;
				tileMap.theMap[i][1] = wallTiles[wy * 3 + wx];
			} 
		}
		tileMap.endEdit();
		stage.addActor(tileMap);
		uiStage = new Stage( Gdx.graphics.getWidth(), Gdx.graphics.getHeight(), true);
		uiStage.getSpriteBatch().getTransformMatrix().scale(1, -1, 1);
		Actor fpsCounter = new Actor() {
			int lastFPS;
			/* (non-Javadoc)
			 * @see com.badlogic.gdx.scenes.scene2d.Actor#draw(com.badlogic.gdx.graphics.g2d.SpriteBatch, float)
			 */
			@Override
			public void draw(SpriteBatch batch, float parentAlpha) {
				// TODO Auto-generated method stub
				BitmapFont fnt = getFont();				
				
				fnt.draw(batch, 
						String.format("FPS:%d", Gdx.graphics.getFramesPerSecond()), getX(), getY());
				this.setSize(30, 10);
			}

			/* (non-Javadoc)
			 * @see com.badlogic.gdx.scenes.scene2d.Actor#act(float)
			 */
			@Override
			public void act(float delta) {
				// TODO Auto-generated method stub
				super.act(delta);
			}

			/* (non-Javadoc)
			 * @see com.badlogic.gdx.scenes.scene2d.Actor#fire(com.badlogic.gdx.scenes.scene2d.Event)
			 */
			@Override
			public boolean fire(Event event) {
				Console.debug("FPSCounter");
				if (event instanceof InputEvent && ((InputEvent)event).getType() == InputEvent.Type.touchDown) {
					Console.debug("FPS counter:%s", event);
				}
				return super.fire(event);
			}
			
			
		};
		fpsCounter.setPosition(10, 20);
		uiStage.addActor(fpsCounter);

	}
	/* (non-Javadoc)
	 * @see com.mutantamoeba.ld25.screens.BasicScreen#render(float)
	 */
	@Override
	public void render(float delta) {	
		OrthographicCamera cam = (OrthographicCamera)stage.getCamera();
		float moveX = 0;
		float moveY = 0;
		float scrollSpeed = 2;
		if (Gdx.input.isKeyPressed(Input.Keys.SHIFT_LEFT)) {
			scrollSpeed *= 3;
		}
		if (Gdx.input.isKeyPressed(Input.Keys.A)) {
			moveX -= scrollSpeed * cam.zoom;
		} 
		if (Gdx.input.isKeyPressed(Input.Keys.D)) {
			moveX += scrollSpeed * cam.zoom;
		} 
		if (Gdx.input.isKeyPressed(Input.Keys.W)) {
			moveY += scrollSpeed * cam.zoom;
		} 
		if (Gdx.input.isKeyPressed(Input.Keys.S)) {
			moveY -= scrollSpeed * cam.zoom;
		} 
		cam.translate(moveX, moveY);
		stage.act(delta);
		
		Gdx.gl.glClearColor(1,0,1,1);
		Gdx.gl.glClear(GL10.GL_COLOR_BUFFER_BIT);
		
		stage.draw();
		
		uiStage.act(delta);
		uiStage.draw();
	}
	/* (non-Javadoc)
	 * @see com.mutantamoeba.ld25.screens.BasicScreen#dispose()
	 */
	@Override
	public void dispose() {
		texture.dispose();
		super.dispose();
	}
	/* (non-Javadoc)
	 * @see com.mutantamoeba.ld25.screens.BasicScreen#scrolled(int)
	 */
	@Override
	public boolean scrolled(int amount) {
//		Console.debug("SCROLLED:%d", amount);
		OrthographicCamera cam = (OrthographicCamera)stage.getCamera(); 
		cam.zoom += amount / 10.0f;
		float minZoom = 0.1f;
		float maxZoom = 10;
		if (cam.zoom < minZoom) {
			cam.zoom = minZoom;
		} else if (cam.zoom > maxZoom) {
			cam.zoom = maxZoom;
		}
		return super.scrolled(amount);
	}
	
	/* (non-Javadoc)
	 * @see com.mutantamoeba.ld25.engine.BasicInputProcessor#touchDown(int, int, int, int)
	 */
	@Override
	public  boolean touchDown(int x, int y, int pointer, int button) {
//		Console.debug("touchdown %d, %d", x, y);
		uiStage.touchDown(x, y, pointer, button);
		return super.touchDown(x, y, pointer, button);
	}


	/* (non-Javadoc)
	 * @see com.mutantamoeba.ld25.engine.BasicInputProcessor#touchUp(int, int, int, int)
	 */
	@Override
	public boolean touchUp(int x, int y, int pointer, int button) {
		uiStage.touchUp(x, y, pointer, button);
		return super.touchUp(x, y, pointer, button);
	}


	/* (non-Javadoc)
	 * @see com.mutantamoeba.ld25.engine.BasicInputProcessor#touchDragged(int, int, int)
	 */
	@Override
	public boolean touchDragged(int x, int y, int pointer) {
		Console.debug("dragged");
		uiStage.touchDragged(x, y, pointer);
		return stage.touchDragged(x, y, pointer);
	}	
}
package com.mutantamoeba.ld25.utils;

import java.io.File;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Properties;

public class MathUtils {
	static public final float PI = 3.141592653589f;
	static public float map(float in, float rMin, float rMax, float oMin, float oMax) {
		return ( (in-rMin) / (rMax-rMin)) * (oMax-oMin) + oMin;
	}
	static public float min(float a, float b) {
		return (a < b ? a : b);
	}
	static public float max(float a, float b) {
		return (a > b ? a : b);
	}
	static public float constrain(float a, float rMin, float rMax) {
		if (a < rMin)
			return rMin;
		else if (a > rMax)
			return rMax;
		return a;
	}
	static public float frac(float a) {
		return a - (int)a;
	}
	
	/* Just a port of well-known code (original source unknown, I found it via the Google Oracle)
	 * 
	 */
	static public double sqrt(final double a) {
	    final long x = Double.doubleToLongBits(a) >> 32;
	    double y = Double.longBitsToDouble((x + 1072632448) << 31);
	 
	    // repeat the following line for more precision
	    y = (y + a / y) * 0.5;
	    return y;
	}	
	
	/* Just a port of well-known code (original source unknown, I found it via the Google Oracle)
	 * 
	 */
	static public float inverseSqrt(double x) {
        final double xhalves = 0.5d * x;
        x = Double.longBitsToDouble(0x5FE6EB50C7B537AAl - (Double.doubleToRawLongBits(x) >> 1));
        
        // repeat the following line for more precision
        x = x * (1.5d - xhalves * x * x);
        return (float)x; 
	}
	
	/* Just a port of well-known code (original source unknown, I found it via the Google Oracle)
	 * 
	 */	
	static public float atan2(float y, float x) {
		float coeff_1 = PI / 4.0f;
		float coeff_2 = 3.0f * coeff_1;
		float abs_y = Math.abs(y);
		float angle;
		if (x >= 0) {
			float r = (x - abs_y) / (x + abs_y);
			angle = coeff_1 - coeff_1 * r;
		} else {
			float r = (x + abs_y) / (abs_y - x);
			angle = coeff_2 - coeff_1 * r;
		}
		return y < 0 ? -angle : angle;
	}
	
	static public double distance(float x1, float y1, float x2, float y2) {
		float x = x2 - x1;
		float y = y2 - y1;
		return sqrt(x*x + y*y);
	}
	static public float degrees(float rads) {
		return (rads * 180.0f) / PI;
	}
	static public float radians(float degs) {
		return (degs * PI) / 180.0f;
	}

	/* The angular distance between startAngle and targetAngle (avoids turns of > 180 degrees)
	 * @param start the source angle
	 * @param target the angle we wish to turn towards
	 */
	static public float dirDelta(float start, float target) {
	    float deltaDir = target - start;
	    
	    // constrain the delta so that our head doesn't spin the long way around
	    while (deltaDir < -PI)
	        deltaDir += 2*PI;
	    while (deltaDir > PI)
	        deltaDir -= 2*PI;
	        
	    return deltaDir;
	}

	/* performs a simple Hermite Blend
	 * 
	 */
	static public float hermiteBlend(float x, float y, float t) {
	    float bl = 3*(t*t) - 2*(t*t*t);
	    return x + (y-x)*bl;
	}

	/* turns a smooth value between 0..1 into a ridged (discrete) value in the same range
	 * @param x the input value (between 0 and 1)
	 * @param ridges how many discrete steps in the result
	 */
    public static float ridge(float x, int ridges) {
        // assumes the value is between 0 and 1
        int i = (int)(x * ridges);
        float stepSize = 1.0f / (float)ridges;        
        float val = i / (float)ridges;
        float frac =(( (x - val) ));

        frac -= 0.5;

        float dest;
        float boundary = 0.45f;
        if (frac < -boundary) {
            dest = val - stepSize;
            frac = map(frac, -0.5f, -boundary, 0, 1);
        } else if (frac > boundary) {
            dest = val + stepSize;
            frac = map(frac, boundary, 0.5f, 1, 0);
        } else {
            dest = val;
            frac = 1.0f;
        }
        val += (dest-val)*(1.0-frac);
        return val;
    }
    
    public static float ridgeFrac(float x, int ridges) {
        // assumes the value is between 0 and 1
        int i = (int)(x * ridges);
        float stepSize = 1.0f / (float)ridges;        
        float val = i / (float)ridges;
        float frac = x - val; 

        return constrain(frac, 0, 1);
    }    
    public static float lerp(float a, float b, float amnt) {
    	return a + (b-a)*amnt;
    }
}
package com.mutantamoeba.ld25.utils;


public class ParameterMap<ContentType> {
    String    _name;
    public final int       _w, _h, _area;
    Object    _map[];
    public ParameterMap(String name, int w, int h, ContentType defaultValue) {
        _w = w;
        _h = h;
        _area = w * h;
        _name = name;
        _map = new Object[_area];
        for (int i=0;i<_area;i++) {
            _map[i] = defaultValue;
        }
    }
    public ContentType get(int x, int y) {
        x = (int)MathUtils.constrain(x, 0, _w-1);
        y = (int)MathUtils.constrain(y, 0, _h-1);
        return (ContentType)_map[y*_w+x];
    }
    public ContentType get(int offs) {
        offs = (int)MathUtils.constrain(offs, 0, _area-1);
        return (ContentType)_map[offs];
    }
    public void set(int x, int y, ContentType v) {
        x = (int)MathUtils.constrain(x, 0, _w-1);
        y = (int)MathUtils.constrain(y, 0, _h-1);
        
        int ix = (int)x;
        int iy = (int)y;
        _map[iy*_w+ix] = v;      
    }
    public void set(int offs, ContentType v) {
        offs = (int)MathUtils.constrain(offs, 0, _area-1);
        _map[offs] = v;
    }    
}package com.mutantamoeba.ld25.utils;

import java.util.Random;

/**
 * @author keili
 *
 */
public class RandomNumbers {
	static public Random rand = new Random();
	
	// wrapping java.util.Random functions
	static public float nextFloat() { return rand.nextFloat(); }
	static public double nextGaussian() { return rand.nextGaussian(); }	
	static public int nextInt() { return rand.nextInt(); }
	static public int nextInt(int lim) { return rand.nextInt(lim); }
	static public boolean nextBoolean() { return rand.nextBoolean(); }	
	static public void setSeed(long seed) { rand.setSeed(seed); }
	
	/** chooses the index of a list of probabilities at random
	 * 
	 * @param chances a list of integer weights
	 * @return the index of the chosen weight
	 */
	static public int weightedRandom(int... chances) {
	    int total = 0;
	    for (Integer chance:chances) {
	        total += chance;
	    }
	    int val = nextInt(total);
	    
	    int accum = 0;
	    for (int i=0;i<chances.length;i++) {
	        accum += chances[i];
	        if (val < accum) {
	            return i;
	        }
	    }
	    return 0;
	}
	
	/** generates a pseudorandom number based on input coordinates
	 * can be used to seed the random number generator, or just raw
	 * @param x
	 * @param y
	 * @return a random long
	 */
	static public long locHash(int x, int y) {
//	    return ((x * 0x1337) % 157931) * ((y * 319489) % 2696063) + 9876413;
	    return (((x * 10011101 + y) % 53781811) * ((y * 253124999 + x) % 285646799) + 9876413) ^ (x * y * 285646799);    
	}
	
	static public float locFloat(int x, int y) {
		return (float)(locHash(x, y) / (double)Long.MAX_VALUE);
	}
	
}
package com.mutantamoeba.ld25.utils;

import java.io.File;
import java.util.Properties;
import java.util.Map.Entry;

public class StringUtils {
	static public String repeat(char c, int count) {
		String res = "";
		
		for (int i=0;i<count;i++) {
			res += c;
		}
		return res;
	}
	
	public static String join(Object o[], String sep) {
	    String res = "";
	    for (int i=0; i<o.length; i++) {
	        res += o[i].toString();
	        if (i < o.length-1) {
	            res += sep;
	        }
	    }
	    return res;
	}

	public static String join(Object o[], String sep, int spacing) {
	    String res = "";
	    for (int i=0; i<o.length; i++) {
	        res += String.format("%" + Integer.toString(spacing) + "s", o[i].toString());
	        if (i < o.length-1) {
	            res += sep;
	        }
	    }
	    return res;
	}
	public static String herePath(String fname) {
		Properties props = System.getProperties();
		
		for (Entry<Object, Object> prop:props.entrySet()) {
			String propName = (String)prop.getKey();
			Object propVal = prop.getValue();
			System.out.println(propName + ":" + propVal);
		}
//		String currentDir = new File(System.getProperty("user.dir"), fname).getAbsolutePath();
		File file = new File(System.getProperty("user.home"), "Library" + File.separator + 
																"Application Support" + File.separator + 
																"Mutant Amoeba/");
		file.mkdirs();
		file = new File(file.getAbsolutePath(), fname);
		String currentDir = file.getAbsolutePath();
		
		System.out.println(currentDir);
		return currentDir;
	}
}
package com.mutantamoeba.ld25;

import android.os.Bundle;

import com.badlogic.gdx.backends.android.AndroidApplication;
import com.badlogic.gdx.backends.android.AndroidApplicationConfiguration;

public class MainActivity extends AndroidApplication {
    @Override
    public void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        
        AndroidApplicationConfiguration cfg = new AndroidApplicationConfiguration();
        cfg.useGL20 = false;
        
        initialize(new LD25(), cfg);
    }
}package com.mutantamoeba.ld25;

import com.badlogic.gdx.Gdx;
import com.badlogic.gdx.backends.lwjgl.LwjglApplication;
import com.badlogic.gdx.backends.lwjgl.LwjglApplicationConfiguration;

public class Main {
	public static void main(String[] args) {
		LwjglApplicationConfiguration cfg = new LwjglApplicationConfiguration();
		cfg.title = "No, Mister Bond...";
		cfg.useGL20 = false;
		cfg.width = 640;
		cfg.height = 480;		
//		cfg.vSyncEnabled = true;
//		cfg.useCPUSynch = true;
		new LwjglApplication(new LD25(), cfg);
	}
}
