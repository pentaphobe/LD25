package com.mutantamoeba.ld25.actors;

import com.badlogic.gdx.Gdx;
import com.badlogic.gdx.graphics.GL11;
import com.badlogic.gdx.graphics.g2d.SpriteBatch;
import com.badlogic.gdx.scenes.scene2d.Group;
import com.mutantamoeba.ld25.GameWorld;

public class EntityGroup extends Group {
	GameWorld world;
	public EntityGroup(GameWorld world) {
		super();
		this.world = world;
	}
	/* (non-Javadoc)
	 * @see com.badlogic.gdx.scenes.scene2d.Group#drawChildren(com.badlogic.gdx.graphics.g2d.SpriteBatch, float)
	 */
	@Override
	protected void drawChildren(SpriteBatch batch, float parentAlpha) {
//		for (Actor act:this.getChildren()) {
//			Console.debug("%s", act);
//		}
		Gdx.gl.glEnable(GL11.GL_TEXTURE_2D);
		
		super.drawChildren(batch, parentAlpha);
		Gdx.gl.glDisable(GL11.GL_TEXTURE_2D);
	}

}
package com.mutantamoeba.ld25.actors;

import com.badlogic.gdx.Gdx;
import com.badlogic.gdx.scenes.scene2d.InputEvent;
import com.badlogic.gdx.scenes.scene2d.utils.ClickListener;
import com.mutantamoeba.ld25.engine.Console;
import com.mutantamoeba.ld25.screens.BasicScreen;
import com.mutantamoeba.ld25.utils.DebugListener;

public class FpsCounter extends SimpleTextButton {
	BasicScreen screen;
	public FpsCounter(BasicScreen gameScreen) {
		super(gameScreen, "");
		addListener(new ClickListener() {
			/* (non-Javadoc)
			 * @see com.badlogic.gdx.scenes.scene2d.utils.ClickListener#clicked(com.badlogic.gdx.scenes.scene2d.InputEvent, float, float)
			 */
			@Override
			public void clicked(InputEvent event, float x, float y) {
				Console.debug("Clicked FpsCounter");
				event.cancel();
				super.clicked(event, x, y);
			}				
		});
		addListener(new DebugListener("fpsCounter"));
	}
	/* (non-Javadoc)
	 * @see com.badlogic.gdx.scenes.scene2d.Actor#act(float)
	 */
	@Override
	public void act(float delta) {
		setLabel(String.format("FPS:%d", Gdx.graphics.getFramesPerSecond()));
		super.act(delta);
	}


}	package com.mutantamoeba.ld25.actors;

import com.badlogic.gdx.graphics.g2d.SpriteBatch;
import com.badlogic.gdx.graphics.g2d.TextureRegion;
import com.badlogic.gdx.scenes.scene2d.Group;
import com.mutantamoeba.ld25.GameWorld;
import com.mutantamoeba.ld25.Room;
import com.mutantamoeba.ld25.screens.GameScreen;
import com.mutantamoeba.ld25.utils.RandomNumbers;

public class GameEntity extends Group {	
	TextureRegion region;
	Room room;
	public GameEntity(TextureRegion region) {
		super();
		this.region = region;
	}
	/* (non-Javadoc)
	 * @see com.badlogic.gdx.scenes.scene2d.Actor#draw(com.badlogic.gdx.graphics.g2d.SpriteBatch, float)
	 */
	@Override
	public void draw(SpriteBatch batch, float parentAlpha) {
		super.draw(batch, parentAlpha);
		
		batch.draw(region, getX() - getOriginX(), getY() - getOriginY());
		
//		batch.draw(GameScreen.texture, getX() - getWidth()/2, getY() - getHeight()/2, 32, 32, 32 /*texX*/, 40 /*texY*/, 32, 32, false, false);
	}

	/* (non-Javadoc)
	 * @see com.badlogic.gdx.scenes.scene2d.Actor#act(float)
	 */
	@Override
	public void act(float delta) {
		float speed = 3f;
		setPosition(getX() + speed * (RandomNumbers.nextFloat() - 0.5f), getY() + speed * (RandomNumbers.nextFloat() - 0.5f));
		// TODO Auto-generated method stub
		super.act(delta);
	}

	/* (non-Javadoc)
	 * @see com.badlogic.gdx.scenes.scene2d.Actor#setPosition(float, float)
	 */
	@Override
	public void setPosition(float x, float y) {		
		if (updateRoom((int)(x / (GameWorld.ROOM_SIZE * GameScreen.TILE_SIZE)), (int)(y / (GameWorld.ROOM_SIZE * GameScreen.TILE_SIZE)))) {
			super.setPosition(x, y);
		}
	}
	
	private boolean updateRoom(int x, int y) {
		EntityGroup par = ((EntityGroup)this.getParent());
		Room oldRoom = room;
		room = par.world.roomMap.get(x, y);
//		Console.debug("(%d, %d) oldRoom:%s room:%s", x, y, oldRoom, room);
		if (oldRoom != room) {
//			Console.debug("changed rooms to %s [%d, %d]", room, x, y);
			if (room == null) {
				room = oldRoom;
				return false;
			}
		}
		return true;
	}
	
}

package com.mutantamoeba.ld25.actors;

import com.badlogic.gdx.graphics.g2d.NinePatch;
import com.badlogic.gdx.graphics.g2d.SpriteBatch;
import com.badlogic.gdx.scenes.scene2d.Group;

public class SidePanel extends Group {
	NinePatch ninePatch;

	public SidePanel(NinePatch ninePatch) {
		this.ninePatch = ninePatch;
	}
	
	/* (non-Javadoc)
	 * @see com.badlogic.gdx.scenes.scene2d.Group#draw(com.badlogic.gdx.graphics.g2d.SpriteBatch, float)
	 */
	@Override
	public void draw(SpriteBatch batch, float parentAlpha) {
		this.ninePatch.draw(batch, getX(), getY(), getWidth(), getHeight());
		super.draw(batch, parentAlpha);
	}
	
}
package com.mutantamoeba.ld25.actors;

import com.badlogic.gdx.scenes.scene2d.Actor;
import com.badlogic.gdx.scenes.scene2d.InputEvent;
import com.badlogic.gdx.scenes.scene2d.InputListener;

public class SimpleButton extends Actor {
	boolean mouseOver = false;
	SimpleButton() {
		addListener(new InputListener() {

			/* (non-Javadoc)
			 * @see com.badlogic.gdx.scenes.scene2d.InputListener#enter(com.badlogic.gdx.scenes.scene2d.InputEvent, float, float, int, com.badlogic.gdx.scenes.scene2d.Actor)
			 */
			@Override
			public void enter(InputEvent event, float x, float y, int pointer,
					Actor fromActor) {
				mouseOver = true;
				super.enter(event, x, y, pointer, fromActor);
			}

			/* (non-Javadoc)
			 * @see com.badlogic.gdx.scenes.scene2d.InputListener#exit(com.badlogic.gdx.scenes.scene2d.InputEvent, float, float, int, com.badlogic.gdx.scenes.scene2d.Actor)
			 */
			@Override
			public void exit(InputEvent event, float x, float y, int pointer,
					Actor toActor) {
				mouseOver = false;
				super.exit(event, x, y, pointer, toActor);
			}
			
		});
	}
	
}
package com.mutantamoeba.ld25.actors;

import com.badlogic.gdx.graphics.Color;
import com.badlogic.gdx.graphics.g2d.BitmapFont;
import com.badlogic.gdx.graphics.g2d.BitmapFont.TextBounds;
import com.badlogic.gdx.graphics.g2d.SpriteBatch;
import com.mutantamoeba.ld25.screens.BasicScreen;

/* a simple text button with no skinning or anything fancy
 * [@todo this should really just be some kind of Label drawable object whicih gets attached to the SimpleButton]
 * [@... do this if you have time]
 */
public class SimpleTextButton extends SimpleButton {
	BasicScreen screen;
	String label;
	BitmapFont font;
	
	public SimpleTextButton(BasicScreen gameScreen, String label) {
		super();
		
		this.screen = gameScreen;		
		this.font = screen.getFont();
		
		setLabel(label);
	}
	public void setLabel(String label) {
		this.label = label;
		TextBounds bounds = font.getBounds(label);		
		this.setSize(bounds.width, bounds.height);
	}
	
	/* (non-Javadoc)
	 * @see com.badlogic.gdx.scenes.scene2d.Actor#draw(com.badlogic.gdx.graphics.g2d.SpriteBatch, float)
	 */
	@Override
	public void draw(SpriteBatch batch, float parentAlpha) {
		Color oldColor = font.getColor();
		if (mouseOver) {
			font.setColor(1, 0, 0, 1);
		} else {
			font.setColor(1, 1, 1, 1);
		}
		font.draw(batch, label, getX(), getY() + getHeight());
		font.setColor(oldColor);
	}


}
package com.mutantamoeba.ld25.actors;

import com.badlogic.gdx.graphics.g2d.SpriteBatch;
import com.badlogic.gdx.graphics.g2d.TextureRegion;

public class ToolButton extends SimpleButton {
	public static final int NORMAL = 0;
	public static final int HOVER = 1;
	public static final int DOWN = 2;

	TextureRegion background[];
	TextureRegion icon;
	public String toolName;
	public ToolButton(TextureRegion background[], TextureRegion icon, String toolName) {
		super();
		this.toolName = toolName;
		this.setSize(background[0].getRegionWidth(), background[0].getRegionHeight());
		this.background = background;
		this.icon = icon;
	}
	/* (non-Javadoc)
	 * @see com.badlogic.gdx.scenes.scene2d.Actor#draw(com.badlogic.gdx.graphics.g2d.SpriteBatch, float)
	 */
	@Override
	public void draw(SpriteBatch batch, float parentAlpha) {
		int state = NORMAL;
		if (mouseOver) {
			state = HOVER;
		}
		batch.draw(background[state], getX(), getY(), getWidth(), getHeight());
		batch.draw(icon, getX(), getY(), getWidth(), getHeight());
		super.draw(batch, parentAlpha);
	}

}
package com.mutantamoeba.ld25.engine;

import com.badlogic.gdx.InputProcessor;

public abstract class BasicInputProcessor implements InputProcessor {

	@Override
	public boolean keyDown(int keycode) {
		// TODO Auto-generated method stub
		return false;
	}

	@Override
	public boolean keyUp(int keycode) {
		// TODO Auto-generated method stub
		return false;
	}

	@Override
	public boolean keyTyped(char character) {
		// TODO Auto-generated method stub
		return false;
	}

	@Override
	public boolean touchDown(int x, int y, int pointer, int button) {
		// TODO Auto-generated method stub
		return false;
	}

	@Override
	public boolean touchUp(int x, int y, int pointer, int button) {
		// TODO Auto-generated method stub
		return false;
	}

	@Override
	public boolean touchDragged(int x, int y, int pointer) {
		// TODO Auto-generated method stub
		return false;
	}

	@Override
	public boolean mouseMoved(int x, int y) {
		// TODO Auto-generated method stub
		return false;
	}

	@Override
	public boolean scrolled(int amount) {
		// TODO Auto-generated method stub
		return false;
	}

}
package com.mutantamoeba.ld25.engine;

import com.badlogic.gdx.Gdx;
import com.mutantamoeba.ld25.LD25;
import com.mutantamoeba.ld25.utils.StringUtils;

/** Just a basic wrapper for console stuff
 * @author keili
 *
 */
public class Console {
	public static int stackTraceLevels = 0;
	public static void log(String fmt, Object... args) {
		Gdx.app.log(LD25.LOG, String.format(fmt, args));
	}
	public static void debug(String fmt, Object... args) {
		if (LD25.DEBUG_MODE) { 
			int idx = 2;
			StackTraceElement thr = Thread.currentThread().getStackTrace()[idx];
			Gdx.app.debug(LD25.LOG, String.format("%s(%d):", thr.getFileName(), thr.getLineNumber()) + String.format(fmt, args));
			for (int i=0; i<stackTraceLevels; i++) {
				thr = Thread.currentThread().getStackTrace()[idx+i];
				Gdx.app.debug(LD25.LOG, String.format("%scalled from: %s(%d)", StringUtils.repeat(' ', i*2), thr.getFileName(), thr.getLineNumber()));
			}
		}
	}
}
package com.mutantamoeba.ld25;

import com.mutantamoeba.ld25.engine.Console;

public class GameEconomy {
	static final float DEFAULT_STARTING_BUDGET = 10 * 1000;
	private float	currentBudget;
	
	// [@temp just a constant increase]
	float	incomePerSecond = 100f;
	
	GameEconomy() {
		setBudget(DEFAULT_STARTING_BUDGET);
	}

	public void tick(float delta) {
		
		credit(incomePerSecond * delta);		
	}
	
	public void credit(float amount) {
		setBudget(budget() + amount);
	}

	/**
	 * @param currentBudget the currentBudget to set
	 */
	void setBudget(float currentBudget) {
		this.currentBudget = currentBudget;
//		Console.debug("new budget:%.2f", currentBudget);
	}

	/**
	 * @return the currentBudget
	 */
	public float budget() {
		return currentBudget;
	}

	public void debit(float amount) {
		Console.debug("debiting %f", amount);
		Console.debug("  budget before: %f", budget());
		setBudget(budget() - amount);		
		Console.debug("  budget after : %f", budget());
	}
}
package com.mutantamoeba.ld25;

import com.mutantamoeba.ld25.screens.GameScreen;

public abstract class GameTool {
	private GameScreen gameScreen;
	private String name;
	private float cost;
	
	public GameTool(String name, GameScreen gameScreen, float cost) {
		this.gameScreen = gameScreen;
		this.cost = cost;
		this.setName(name);
	}
	public void applyCost() {
		gameScreen.getWorld().getEconomy().debit(cost);
	}
	public boolean canApply() {
		return gameScreen.getWorld().getEconomy().budget() >= cost;
	}
	public abstract void apply(int mx, int my);
	/**
	 * @param name the name to set
	 */
	public void setName(String name) {
		this.name = name;
	}
	/**
	 * @return the name
	 */
	public String getName() {
		return name;
	}
}
package com.mutantamoeba.ld25;

import com.mutantamoeba.ld25.screens.GameScreen;
import com.mutantamoeba.ld25.tilemap.TileMap;

public class GameWorld {
	static GameWorld instance;
	
	public static final int ROOM_SIZE = 5;
	public int mapWidth, mapHeight;
	public int tileMapWidth, tileMapHeight;

	public RoomMap roomMap;
	public TileMap tileMap;
	private GameScreen gameScreen;
	private GameEconomy economy;
	
	public GameWorld(GameScreen gameScreen, int mapWidth, int mapHeight) {
		this.instance = this;
		this.gameScreen(gameScreen);
		this.mapWidth = mapWidth;
		this.mapHeight = mapHeight;
		roomMap = new RoomMap(this, mapWidth, mapHeight);
		this.tileMapWidth = mapWidth * ROOM_SIZE;
		this.tileMapHeight = mapHeight * ROOM_SIZE;
		tileMap = new TileMap(this, this.tileMapWidth, this.tileMapHeight);
		
		economy = new GameEconomy();
	}
	
	public void tick(float delta) {
		economy.tick(delta);
	}
	
	public static GameWorld instance() {
		return instance;
	}

	/**
	 * @param gameScreen the gameScreen to set
	 */
	public void gameScreen(GameScreen gameScreen) {
		this.gameScreen = gameScreen;
	}

	/**
	 * @return the gameScreen
	 */
	public GameScreen gameScreen() {
		return gameScreen;
	}

	/**
	 * @param economy the economy to set
	 */
	public void setEconomy(GameEconomy economy) {
		this.economy = economy;
	}

	/**
	 * @return the economy
	 */
	public GameEconomy getEconomy() {
		return economy;
	}
}
package com.mutantamoeba.ld25;

import com.badlogic.gdx.Game;
import com.badlogic.gdx.Gdx;
import com.mutantamoeba.ld25.engine.Console;
import com.mutantamoeba.ld25.screens.MainMenuScreen;

public class LD25 extends Game {
	public static boolean DEBUG_MODE = true;
	public static final String VERSION = "0.0.2";
	public static final String LOG = "NoMisterBond";
	
	static LD25 instance;
	
	@Override
	public void create() {	
		if (DEBUG_MODE) {
			Gdx.app.setLogLevel(Gdx.app.LOG_DEBUG);
		}
		Console.debug("create");
//		if (DEBUG_MODE) {
			// skip the splash screen if we're in debug mode
			setScreen(new MainMenuScreen(this));
//		} else {
//			setScreen(new SplashScreen(this));		
//		}	
//		setScreen(new GameScreen(this));
//		setScreen(new TileTestScreen(this));
		
		Gdx.graphics.setVSync(true);
	}
	
	@Override
	public void dispose() {
		Console.debug("got to dispose");
		super.dispose();
	}
	
	public static LD25 instance() {
		if (instance == null) {
			instance = new LD25();
		}
		return instance;
	}
}
package com.mutantamoeba.ld25;

public class Room {
	int mapX, mapY;
	Room up, down, left, right;
	RoomConfig config;
	public Room(RoomConfig config, int mapX, int mapY) {
		this.mapX = mapX;
		this.mapY = mapY;	
		this.config = config;
	}
	public Room(int mapX, int mapY) {
		this(new RoomConfig(), mapX, mapY);
	}
	public String toString() {
		return String.format("%s {up:%s, down:%s, left:%s, right:%s}", Room.toString(this, false), Room.toString(up, false), Room.toString(down, false),
				Room.toString(left, false), Room.toString(right, false));
	}
	public static String toString(Room room, boolean recurse) {
		if (room == null) return "Room[null]";
		if (recurse) {
			return room.toString();
		} 
		return String.format("Room[%d, %d]", room.mapX, room.mapY);
	}
	public String infoString() {
		return String.format("type  : %s\n" +
							 "health: %.0f\n" +
							 "level : %d\n", config.type, config.health, config.level);
	}
}
package com.mutantamoeba.ld25;

public class RoomConfig {
	String type;
	int level;
	float health;
	RoomConfig(String type, int level) {
		this.type = type;
		this.level = level;
		this.health = 100;
	}
	RoomConfig() {
		this("vanilla", 1);
	}
}
package com.mutantamoeba.ld25;

import com.mutantamoeba.ld25.engine.Console;
import com.mutantamoeba.ld25.tilemap.Tile;
import com.mutantamoeba.ld25.utils.ParameterMap;
import com.mutantamoeba.ld25.utils.RandomNumbers;


/** The logical map
 * @author keili
 *
 */
public class RoomMap extends ParameterMap<Room> {
	private GameWorld world;

	public RoomMap(GameWorld world, int w, int h) {
		super("rooms", w, h, null);
		this.world = world;
	}
	public void makeTemplatedRoom(int x, int y /*, Template template */) {
		// [@temp use real templates from a data file]
		int idx = RandomNumbers.nextInt(5);
		switch (idx) {
		case 0:
			makeBlankRoom(new RoomConfig("gas chamber", 3), x, y, new int[] {
					-1, -1, -1, -1, -1,
					-1, 40, -1, 40, -1,
					-1, -1, -1, -1, -1,
					-1, 40, -1, 40, -1,
					-1, -1, -1, -1, -1			
				});
			break;
		case 1:
			makeBlankRoom(new RoomConfig("trap doors", 2), x, y, new int[] {
					-1, -1, -1, -1, -1,
					-1, -1, 56, -1, -1,
					-1, 56, -1, 56, -1,
					-1, -1, 56, -1, -1,
					-1, -1, -1, -1, -1			
				});
			break;
		case 2:
			makeBlankRoom(new RoomConfig("trap doors", 3), x, y, new int[] {
					-1, -1, -1, -1, -1,
					-1, 57, -1, 57, -1,
					-1, -1, 57, -1, -1,
					-1, 57, -1, 57, -1,
					-1, -1, -1, -1, -1			
				});
			break;
		case 3:
			makeBlankRoom(new RoomConfig("wall darts", 4), x, y, new int[] {
					-1, -1, -1, 51, -1,
					48, -1, -1, -1, -1,
					-1, -1, -1, -1, -1,
					-1, -1, -1, -1, 49,
					-1, 50, -1, -1, -1			
				});
			break;
		case 4:
			makeBlankRoom(new RoomConfig("turrets", 4), x, y, new int[] {
					35, -1, -1, -1, 34,
					-1, -1, -1, -1, -1,
					-1, -1, -1, -1, -1,
					-1, -1, -1, -1, -1,
					32, -1, -1, -1, 33			
				});
			break;
		case 5:
			makeBlankRoom(x, y, new int[] {
					-1, -1, -1, -1, -1,
					-1, -1, -1, -1, -1,
					-1, -1, -1, -1, -1,
					-1, -1, -1, -1, -1,
					-1, -1, -1, -1, -1			
				});
			break;
						
		}
		
	}
	public Room makeBlankRoom(int x, int y) {
		return makeBlankRoom(new RoomConfig(), x, y, null);
	}
	public Room makeBlankRoom(int x, int y, int objects[]) {
		return makeBlankRoom(new RoomConfig(), x, y, objects);
	}
	public Room makeBlankRoom(RoomConfig config, int x, int y, int objects[]) {
		Room r = get(x, y);
		if (r != null) {
			return r;
		}
		r = new Room(config, x, y);
		super.set(x, y, r);
		int floorId = this.world.gameScreen().gameTiles.getId("floor");
		int wallId = this.world.gameScreen().gameTiles.getId("wall");
		int wallIndices[] = this.world.gameScreen().gameTiles.getTileIndices(wallId);
		
		int tileX = x * GameWorld.ROOM_SIZE;
		int tileY = y * GameWorld.ROOM_SIZE;
		for (int yy = 0, offs=0; yy < GameWorld.ROOM_SIZE; yy++) {
			boolean top = yy == 0;
			boolean bottom = yy == GameWorld.ROOM_SIZE-1;
			
			for (int xx = 0; xx < GameWorld.ROOM_SIZE; xx++, offs++) {
				Tile tile = new Tile();
				tile.layers[Tile.FLOOR_LAYER] = this.world.gameScreen().gameTiles.getTileIndex(xx, yy, floorId);
				boolean left = xx == 0;
				boolean right = xx == GameWorld.ROOM_SIZE-1;
				if (left || right || top || bottom) {
					// we're on an edge, so apply the nine patch
					int index = -1;
					if (left) {
						if (top) {
							index = 0;
						} else if (bottom) {
							index = 6;
						} else {
							index = 3;
						}
					} else if (right) {
						if (top) {
							index = 2;
						} else if (bottom) {
							index = 8;
						} else {
							index = 5;
						}
					} else if (top) {
						index = 1;
					} else if (bottom) {
						index = 7;
					}
//					Console.debug("creating wall tileIndex:%d %s %s %s %s", index, left ? "left":"", right ? "right":"", top ? "top":"", bottom ? "bottom":"");
					tile.layers[Tile.WALL_LAYER] = wallIndices[index];
				}
				if (objects != null && objects[offs] != -1) {
					tile.layers[Tile.HAZARD_LAYER] = objects[offs];
				}
				world.tileMap.set(tileX + xx, tileY + yy, tile);
			}
		}
		updateDoors(x, y);
		return r;
	}
	/* (non-Javadoc)
	 * @see com.mutantamoeba.ld25.utils.ParameterMap#set(int, int, java.lang.Object)
	 */
	@Override
	public void set(int x, int y, Room v) {		
		super.set(x, y, v);
		updateDoors(x, y);
	}
	
	public void remove(int x, int y) {
		int tileX = x * GameWorld.ROOM_SIZE;
		int tileY = y * GameWorld.ROOM_SIZE;
		for (int yy = 0, offs=0; yy < GameWorld.ROOM_SIZE; yy++) {			
			for (int xx = 0; xx < GameWorld.ROOM_SIZE; xx++, offs++) {
				Tile tile = this.world.tileMap.get(tileX + xx, tileY + yy);
				tile.clear();
			}
		}
		set(x, y, null);
		updateDoors(x-1, y);
		updateDoors(x+1, y);
		updateDoors(x, y-1);
		updateDoors(x, y+1);
	}
	
	public void setRoomTile(Room r, int rx, int ry, int layer, int tileIdx) {
		int tileX = r.mapX * GameWorld.ROOM_SIZE + rx;
		int tileY = r.mapY * GameWorld.ROOM_SIZE + ry;
		Tile tile = world.tileMap.get(tileX, tileY);
		if (tile == null) return;
		tile.layers[layer] = tileIdx;
	}
	
	public Tile setRoomTile(Room r, int rx, int ry) {
		int tileX = r.mapX * GameWorld.ROOM_SIZE + rx;
		int tileY = r.mapY * GameWorld.ROOM_SIZE + ry;
		Tile tile = world.tileMap.get(tileX, tileY);
		return tile;
	}	
	
	private void updateDoors(int x, int y) {
//		Console.debug("updateDoors(%d, %d)", x, y);
		Room me = get(x, y);
//		Console.debug("  before: %s", me);
		if (me == null) return;
		Room left = get(x-1, y);
		Room right = get(x+1, y);
		Room up = get(x, y-1);
		Room down = get(x, y+1);
		me.up = up;
		me.down = down;
		me.left = left;
		me.right = right;
		
		int wallId = this.world.gameScreen().gameTiles.getId("wall");
		int wallIndices[] = this.world.gameScreen().gameTiles.getTileIndices(wallId);
		// the second line in each of these assignments looks weird because it's defined
		// in terms of the target room ("me") just for clarity of reading 
		// (one might argue that if it was so clear, no explanation would be needed)
		if (up != null) {
			setRoomTile(me, 2, 0, Tile.WALL_LAYER, -1);
			setRoomTile(me, 2, -1, Tile.WALL_LAYER, -1);
		} else {
			setRoomTile(me, 2, 0, Tile.WALL_LAYER, wallIndices[1]);
			setRoomTile(me, 2, -1, Tile.WALL_LAYER, -1);
		}
		if (down != null) {
			setRoomTile(me, 2, 4, Tile.WALL_LAYER, -1);
			setRoomTile(me, 2, 5, Tile.WALL_LAYER, -1);
		}else {
			setRoomTile(me, 2, 4, Tile.WALL_LAYER, wallIndices[7]);
			setRoomTile(me, 2, 5, Tile.WALL_LAYER, -1);
		}
		if (left != null) {
			setRoomTile(me, 0, 2, Tile.WALL_LAYER, -1);
			setRoomTile(me, -1, 2, Tile.WALL_LAYER, -1);
		}else {
			setRoomTile(me, 0, 2, Tile.WALL_LAYER, wallIndices[3]);
			setRoomTile(me, -1, 2, Tile.WALL_LAYER, -1);
		}
		if (right != null) {
			setRoomTile(me, 4, 2, Tile.WALL_LAYER, -1);
			setRoomTile(me, 5, 2, Tile.WALL_LAYER, -1);
		}else {
			setRoomTile(me, 4, 2, Tile.WALL_LAYER, wallIndices[5]);
			setRoomTile(me, 5, 2, Tile.WALL_LAYER, -1);
		}
//		Console.debug("   after: %s", me);
	
	}
}
package com.mutantamoeba.ld25;

import com.badlogic.gdx.Gdx;
import com.badlogic.gdx.graphics.GL10;
import com.badlogic.gdx.graphics.GL11;
import com.badlogic.gdx.graphics.GL20;
import com.badlogic.gdx.graphics.g2d.SpriteBatch;
import com.badlogic.gdx.graphics.glutils.ImmediateModeRenderer;
import com.badlogic.gdx.graphics.glutils.ImmediateModeRenderer10;
import com.badlogic.gdx.graphics.glutils.ImmediateModeRenderer20;
import com.badlogic.gdx.scenes.scene2d.Actor;
import com.mutantamoeba.ld25.engine.Console;
import com.mutantamoeba.ld25.screens.GameScreen;

public class RoomRenderer extends Actor {
	static final int DEBUG_VERTICES = 32;
	boolean DEBUG_LINES = false;;
	ImmediateModeRenderer debugRenderer;
	
	GameWorld world;
	public RoomRenderer(GameWorld world) {
		super(); 
		setSize(world.mapWidth * world.ROOM_SIZE * GameScreen.TILE_SIZE, world.mapHeight * world.ROOM_SIZE * GameScreen.TILE_SIZE);
		this.world = world;
		if (Gdx.graphics.isGL20Available())
			debugRenderer = new ImmediateModeRenderer20(DEBUG_VERTICES, false, true, 0);
		else
			debugRenderer = new ImmediateModeRenderer10(DEBUG_VERTICES);
	}
	
	@Override
	public void draw(SpriteBatch batch, float delta) {
		// TEMPORARY
				
		if (LD25.DEBUG_MODE && DEBUG_LINES) {
			debugRenderer.begin(batch.getProjectionMatrix(), GL10.GL_LINES);
			debugRenderer.color(1, 0, 1, 0.5f);
			int roomSizeInTiles = GameScreen.TILE_SIZE * world.ROOM_SIZE;
			
			for (int y=0;y<world.mapWidth;y++) {
				float ry = y * roomSizeInTiles;
				for (int x=0;x<world.mapHeight;x++) {
					float rx = x * roomSizeInTiles;
	//				debugRenderer.vertex(rx, ry, 0);
	//				debugRenderer.vertex(rx, ry+roomSizeInTiles, 0);
	//				
	//				debugRenderer.vertex(rx, ry+roomSizeInTiles, 0);
	//				debugRenderer.vertex(rx+roomSizeInTiles, ry+roomSizeInTiles, 0);
	//				
	//				debugRenderer.vertex(rx+roomSizeInTiles, ry+roomSizeInTiles, 0);
	//				debugRenderer.vertex(rx+roomSizeInTiles, ry, 0);
	//				
	//				debugRenderer.vertex(rx+roomSizeInTiles, ry, 0);
	//				debugRenderer.vertex(rx, ry, 0);
					
					addLine(batch, rx, ry, rx, ry+roomSizeInTiles);
					
					addLine(batch, rx, ry+roomSizeInTiles, rx+roomSizeInTiles, ry+roomSizeInTiles);
					
					addLine(batch, rx+roomSizeInTiles, ry+roomSizeInTiles, rx+roomSizeInTiles, ry);
					
					addLine(batch, rx+roomSizeInTiles, ry, rx, ry);								
				}
			}
			debugRenderer.end();
		}
		// END TEMPORARY		
	}
	void addLine(SpriteBatch batch, float x, float y, float x2, float y2) {
		if (debugRenderer.getNumVertices() == DEBUG_VERTICES) {
			debugRenderer.end();
			debugRenderer.begin(batch.getProjectionMatrix(), GL10.GL_LINES);					
		}
		
		debugRenderer.vertex(x, y, 0);
		debugRenderer.vertex(x2, y2, 0);
		
	}
	/* (non-Javadoc)
	 * @see com.badlogic.gdx.scenes.scene2d.Actor#act(float)
	 */
	@Override
	public void act(float delta) {
		
		super.act(delta);
	}
}
package com.mutantamoeba.ld25.screens;


import com.badlogic.gdx.Game;
import com.badlogic.gdx.Screen;
import com.mutantamoeba.ld25.engine.BasicInputProcessor;

public abstract class AbstractScreen extends BasicInputProcessor implements Screen {
	protected final Game game;
	
	public AbstractScreen(Game game) {
		this.game = game;
	}

}
package com.mutantamoeba.ld25.screens;

import com.badlogic.gdx.Game;
import com.badlogic.gdx.Gdx;
import com.badlogic.gdx.InputMultiplexer;
import com.badlogic.gdx.graphics.GL10;
import com.badlogic.gdx.graphics.g2d.BitmapFont;
import com.badlogic.gdx.scenes.scene2d.Stage;
import com.mutantamoeba.ld25.engine.Console;

public abstract class BasicScreen extends AbstractScreen {
	protected Stage stage;
	protected Stage uiStage;
	private BitmapFont font;	
	protected InputMultiplexer inputMultiplexer;
	boolean clearScreen = true;
	
	public BasicScreen(Game game) {
		super(game);
		stage = new Stage( Gdx.graphics.getWidth(), Gdx.graphics.getHeight(), true);
		stage.getSpriteBatch().getProjectionMatrix().scl(1, -1, 1);

		uiStage = new Stage( Gdx.graphics.getWidth(), Gdx.graphics.getHeight(), true);
		
		
		inputMultiplexer = new InputMultiplexer();
		Gdx.input.setInputProcessor(inputMultiplexer);
		
		inputMultiplexer.addProcessor(this);		
		inputMultiplexer.addProcessor(0, uiStage);			
		inputMultiplexer.addProcessor(stage);
	}

	
	public BitmapFont getFont() {
		if (font == null) {
			font = new BitmapFont(Gdx.files.internal("skin/default.fnt"), false);
		}
		return font;
	}
	
	public Stage getStage() {
		return stage;
	}
	
	@Override
	public void render(float delta) {	
		if (clearScreen) {
			Gdx.gl.glClearColor(0,0,0,1);
			Gdx.gl.glClear(GL10.GL_COLOR_BUFFER_BIT);
		}
		
		update(delta);
		
		stage.draw();
		uiStage.draw();		
	}
	
	public void update(float delta) {
		stage.act(delta);
		uiStage.act(delta);
	}	

	@Override
	public void resize(int width, int height) {
		stage.setViewport(width, height, true);
		
		// updates the viewport preventing GUI scaling, but also requires adjustment of all widgets
//		uiStage.setViewport(width, height, true);
	}

	@Override
	public void dispose() {
		font.dispose();
		stage.dispose();
		uiStage.dispose();
	}

	public void toggleFullscreen() {
		if (Gdx.graphics.isFullscreen()) {
			Console.debug("disabling fullscreen");
			Gdx.graphics.setDisplayMode(Gdx.graphics.getWidth(), Gdx.graphics.getHeight(), false);
		} else {
			Console.debug("enabling fullscreen");
			Gdx.graphics.setDisplayMode(Gdx.graphics.getWidth(), Gdx.graphics.getHeight(), true);
		}
		resize(Gdx.graphics.getWidth(), Gdx.graphics.getHeight());
	}	
	
	@Override
	public void show() {
		// TODO Auto-generated method stub		
		Console.debug("Show");
	}

	@Override
	public void hide() {
		// TODO Auto-generated method stub
		Console.debug("Hide");
	}

	@Override
	public void pause() {
		// TODO Auto-generated method stub
		Console.debug("Pause");
	}

	@Override
	public void resume() {
		// TODO Auto-generated method stub
		Console.debug("Resume");
	}


	/**
	 * @return the clearScreen
	 */
	public boolean isClearScreen() {
		return clearScreen;
	}


	/**
	 * @param clearScreen the clearScreen to set
	 */
	public void setClearScreen(boolean clearScreen) {
		this.clearScreen = clearScreen;
	}

}
package com.mutantamoeba.ld25.screens;

import com.badlogic.gdx.Game;
import com.badlogic.gdx.Gdx;
import com.badlogic.gdx.Input;
import com.badlogic.gdx.graphics.OrthographicCamera;
import com.badlogic.gdx.graphics.Texture;
import com.badlogic.gdx.graphics.Texture.TextureFilter;
import com.badlogic.gdx.graphics.Texture.TextureWrap;
import com.badlogic.gdx.graphics.g2d.NinePatch;
import com.badlogic.gdx.graphics.g2d.ParticleEffect;
import com.badlogic.gdx.graphics.g2d.TextureRegion;
import com.badlogic.gdx.graphics.glutils.ShaderProgram;
import com.badlogic.gdx.math.Vector2;
import com.badlogic.gdx.scenes.scene2d.Actor;
import com.badlogic.gdx.scenes.scene2d.InputEvent;
import com.badlogic.gdx.scenes.scene2d.utils.ClickListener;
import com.badlogic.gdx.scenes.scene2d.utils.DragListener;
import com.badlogic.gdx.utils.ObjectMap;
import com.mutantamoeba.ld25.GameTool;
import com.mutantamoeba.ld25.GameWorld;
import com.mutantamoeba.ld25.LD25;
import com.mutantamoeba.ld25.Room;
import com.mutantamoeba.ld25.RoomRenderer;
import com.mutantamoeba.ld25.actors.EntityGroup;
import com.mutantamoeba.ld25.actors.FpsCounter;
import com.mutantamoeba.ld25.actors.GameEntity;
import com.mutantamoeba.ld25.actors.SidePanel;
import com.mutantamoeba.ld25.actors.SimpleTextButton;
import com.mutantamoeba.ld25.actors.ToolButton;
import com.mutantamoeba.ld25.engine.Console;
import com.mutantamoeba.ld25.tilemap.GameTileset;
import com.mutantamoeba.ld25.tilemap.TileRenderer;
import com.mutantamoeba.ld25.tilemap.TileSubset;

public class GameScreen extends BasicScreen {
	static final int WORLD_WIDTH = 16;
	static final int WORLD_HEIGHT = 16;
	public static final int TILE_SIZE = 32;
	static final float SCROLL_SPEED = 200f; // pixels per second
	static final float SCROLL_FAST_MULTIPLIER = 3f; // how much faster than SCROLL_SPEED do we go in fast mode?
	private static final float SIDEPANEL_WIDTH = 90;
	
	public Texture texture;
	boolean showFPS = true;

	private GameWorld world;
	RoomRenderer roomRenderer;
	TileRenderer tileRenderer;
	public GameTileset gameTiles;
	private EntityGroup entities;
	private Room currentRoom;
	RoomInspector roomInspector;
	private ObjectMap<String, GameTool> tools = new ObjectMap<String, GameTool>();
	protected GameTool currentTool;
	private SidePanel sidePanel;
	private ParticleEffect particleEffect;
	

	public GameScreen(Game game) {
		super(game);
//		setClearScreen(false);
		
		texture = new Texture("data/tiles.png");
		texture.setFilter(TextureFilter.Nearest, TextureFilter.Nearest);
		texture.setWrap(TextureWrap.ClampToEdge, TextureWrap.ClampToEdge);
		gameTiles = new GameTileset(texture, 32);

		gameTiles.addSubset("blank", TileSubset.Type.MULTI, 26, 27);		
//		gameTiles.addSubset("blank", TileSubset.Type.MULTI, 27, 24);
		gameTiles.addSubset("wall", TileSubset.Type.NINEPATCH, 16, 17, 18, 8, 9, 10, 0, 1, 2 );
		gameTiles.addSubset("floor", TileSubset.Type.SINGLE, 24);
		
		if (Gdx.graphics.isGL20Available()) {
			stage.getSpriteBatch().setShader(createShader());
		}
		
//		uiStage.getSpriteBatch().getTransformMatrix().scale(1, -1, 1);
		
//		uiStage.getCamera().combined.set

		setupUI();
		
		particleEffect = new ParticleEffect();
		particleEffect.load(Gdx.files.internal("data/particleEffects.p"), Gdx.files.internal("data"));
		particleEffect.setPosition(0, 0);
		
		
		setWorld(new GameWorld(this, WORLD_WIDTH, WORLD_HEIGHT));
		
		tileRenderer = new TileRenderer(getWorld(), gameTiles);
		stage.addActor(tileRenderer);
		tileRenderer.updateFromMap();
		
		roomRenderer = new RoomRenderer(getWorld());
		roomRenderer.addListener(new ClickListener() {
			/* (non-Javadoc)
			 * @see com.badlogic.gdx.scenes.scene2d.InputListener#touchDown(com.badlogic.gdx.scenes.scene2d.InputEvent, float, float, int, int)
			 */
			@Override
			public void clicked(InputEvent event, float x, float y) {				
				float rx = x / (TILE_SIZE * GameWorld.ROOM_SIZE);
				float ry = y / (TILE_SIZE * GameWorld.ROOM_SIZE);

				// test behaviour
//				if (world.roomMap.get((int)rx, (int)ry) == null) {
//					world.roomMap.makeTemplatedRoom((int)rx, (int)ry);				
//					tileRenderer.updateFromMap();
//				}					
//				selectRoom((int)rx, (int)ry);
				if (currentTool != null) {
					currentTool.apply((int)rx, (int)ry);
				}
				
				super.clicked(event, x, y);
			}			
		});
		roomRenderer.addListener(new DragListener() {
			/* (non-Javadoc)
			 * @see com.badlogic.gdx.scenes.scene2d.InputListener#touchDown(com.badlogic.gdx.scenes.scene2d.InputEvent, float, float, int, int)
			 */
			@Override
			public void drag(InputEvent event, float x, float y, int pointer) {				
				x /= TILE_SIZE * GameWorld.ROOM_SIZE;
				y /= TILE_SIZE * GameWorld.ROOM_SIZE;

				// test behaviour
//				if (world.roomMap.get((int)x, (int)y) == null) {
//					world.roomMap.makeTemplatedRoom((int)x, (int)y);
//					tileRenderer.updateFromMap();
//				}
//				selectRoom((int)x, (int)y);
				if (currentTool != null) {
					currentTool.apply((int)x, (int)y);
				}
				super.drag(event, x, y, pointer);
			}			
		});
		stage.addActor(roomRenderer);
		
		this.entities = new EntityGroup(getWorld());
		
		stage.addActor(this.entities);

//		OrthographicCamera cam = (OrthographicCamera)stage.getCamera();
//		cam.translate(1000, 1000);
	}
	
	private void setupUI() {
		Actor fpsCounter = new FpsCounter(this);
		fpsCounter.setPosition(Gdx.graphics.getWidth() - 60, Gdx.graphics.getHeight() - 20);
		uiStage.addActor(fpsCounter);	
		
		SimpleTextButton budget = new SimpleTextButton(this, "") {

			/* (non-Javadoc)
			 * @see com.badlogic.gdx.scenes.scene2d.Actor#act(float)
			 */
			@Override
			public void act(float delta) {
				setLabel(String.format("budget: $%.2f", getWorld().getEconomy().budget()));
				super.act(delta);
			}
			
		};
		budget.setPosition(10, Gdx.graphics.getHeight() - 20);		
		uiStage.addActor(budget);
		
		TextureRegion region = new TextureRegion(texture, 192, 192, 64, 64);
		NinePatch ninePatch = new NinePatch(region);
		ninePatch.setTopHeight(8);
		ninePatch.setBottomHeight(8);
		ninePatch.setLeftWidth(8);
		ninePatch.setRightWidth(8);
		ninePatch.setPadding(2, 2, 0, 1);
		
		roomInspector = new RoomInspector(ninePatch, getFont());
		roomInspector.setSize(200, 150);
		roomInspector.setPosition(Gdx.graphics.getWidth() - roomInspector.getWidth(), Gdx.graphics.getHeight() - roomInspector.getHeight() - fpsCounter.getHeight() - 5);

		///////// [@note this is the first object in the list now]
		uiStage.getActors().insert(0, roomInspector);
		
		region = new TextureRegion(texture, 192, 160, 32, 32);
		NinePatch panelPatch = new NinePatch(region, 2, 2, 2, 2);
//		panelPatch.setTopHeight(2);
//		panelPatch.setBottomHeight(2);
//		panelPatch.setLeftWidth(2);
//		panelPatch.setRightWidth(2);
//		panelPatch.setMiddleWidth(28);
//		panelPatch.setMiddleHeight(28);
		sidePanel = new SidePanel(panelPatch);
		sidePanel.setBounds(-1, -1, 96, Gdx.graphics.getHeight()+2);
		uiStage.getActors().insert(0, sidePanel);
		
		TextureRegion buttRegions[] = new TextureRegion[3];
		buttRegions[ToolButton.NORMAL] = new TextureRegion(texture, 160, 128, 32, 32);
		buttRegions[ToolButton.HOVER] = new TextureRegion(texture, 192, 128, 32, 32);
		buttRegions[ToolButton.DOWN] = new TextureRegion(texture, 224, 128, 32, 32);
		
		ClickListener toolSelectCallback = new ClickListener() {
			/* (non-Javadoc)
			 * @see com.badlogic.gdx.scenes.scene2d.utils.ClickListener#clicked(com.badlogic.gdx.scenes.scene2d.InputEvent, float, float)
			 */
			@Override
			public void clicked(InputEvent event, float x, float y) {
				event.cancel();
				String toolName = ((ToolButton)event.getTarget()).toolName;
				selectTool(toolName);
				super.clicked(event, x, y);
			}			
		};
		
		ToolButton butt = new ToolButton(buttRegions, new TextureRegion(texture, 128, 96, 32, 32), "remove");
		butt.setBounds(10, 30, 64, 64);
		butt.addListener(toolSelectCallback);
		sidePanel.addActor(butt);

		butt = new ToolButton(buttRegions, new TextureRegion(texture, 160, 96, 32, 32), "gas");
		butt.setBounds(10, 94, 64, 64);
		butt.addListener(toolSelectCallback);
		sidePanel.addActor(butt);
		
		butt = new ToolButton(buttRegions, new TextureRegion(texture, 192, 96, 32, 32), "laser");
		butt.setBounds(10, 158, 64, 64);
		butt.addListener(toolSelectCallback);
		sidePanel.addActor(butt);		
		
		butt = new ToolButton(buttRegions, new TextureRegion(texture, 224, 96, 32, 32), "dart");
		butt.setBounds(10, 222, 64, 64);
		butt.addListener(toolSelectCallback);
		sidePanel.addActor(butt);		
		
		setupTools();
	}
	public void setupTools() {
		GameTool tool = new GameTool("remove", this, 200) {
			@Override
			public void apply(int mx, int my) {
				if (canApply()) {
					getWorld().roomMap.remove(mx, my);
					tileRenderer.updateFromMap();
					applyCost();
				}
			}
			
		};
		tools.put(tool.getName(), tool);
		
		tool = new GameTool("gas", this, 1000) {
			@Override
			public void apply(int mx, int my) {
				if (canApply() && getWorld().roomMap.get((int)mx, (int)my) == null) {
					getWorld().roomMap.makeTemplatedRoom((int)mx, (int)my);
					tileRenderer.updateFromMap();
					applyCost();
				}
				selectRoom((int)mx, (int)my);						
			}
			
		};
		tools.put(tool.getName(), tool);	
		
		tool = new GameTool("laser", this, 1000) {
			@Override
			public void apply(int mx, int my) {
				if (canApply() && getWorld().roomMap.get((int)mx, (int)my) == null) {
					getWorld().roomMap.makeTemplatedRoom((int)mx, (int)my);
					tileRenderer.updateFromMap();
					applyCost();
				}
				selectRoom((int)mx, (int)my);						
			}
			
		};
		tools.put(tool.getName(), tool);			
		
		
		tool = new GameTool("dart", this, 1000) {
			@Override
			public void apply(int mx, int my) {
				if (canApply() && getWorld().roomMap.get((int)mx, (int)my) == null) {
					getWorld().roomMap.makeTemplatedRoom((int)mx, (int)my);
					tileRenderer.updateFromMap();
					applyCost();
				}
				selectRoom((int)mx, (int)my);						
			}
			
		};
		tools.put(tool.getName(), tool);
		
	}
	
	public void selectTool(String toolName) {
		Console.debug("tool select:%s", toolName);
		if (!tools.containsKey(toolName)) {
			Console.debug("no tool implemented for %s", toolName);
			return;
		}
		currentTool = tools.get(toolName);
	}

	private ShaderProgram createShader() {
	
		String vertexShader = "attribute vec4 " + ShaderProgram.POSITION_ATTRIBUTE + ";\n" //
			+ "attribute vec4 " + ShaderProgram.COLOR_ATTRIBUTE + ";\n" //
			+ "attribute vec2 " + ShaderProgram.TEXCOORD_ATTRIBUTE + "0;\n" //
			+ "uniform mat4 u_projTrans;\n" //
			+ "varying vec4 v_color;\n" //
			+ "varying vec2 v_texCoords;\n" //
			+ "\n" //
			+ "void main()\n" //
			+ "{\n" //
			+ "   v_color = " + ShaderProgram.COLOR_ATTRIBUTE + ";\n" //
			+ "   v_texCoords = " + ShaderProgram.TEXCOORD_ATTRIBUTE + "0;\n" //
			+ "   gl_Position =  u_projTrans * " + ShaderProgram.POSITION_ATTRIBUTE + ";\n" //
			+ "}\n";
		String fragmentShader = "#ifdef GL_ES\n" //
			+ "#define LOWP lowp\n" //
			+ "precision mediump float;\n" //
			+ "#else\n" //
			+ "#define LOWP \n" //
			+ "#endif\n" //
			+ "varying LOWP vec4 v_color;\n" //
			+ "varying vec2 v_texCoords;\n" //
			+ "uniform sampler2D u_texture;\n" //
			+ "void main()\n"//
			+ "{\n" //			
			+ "  gl_FragColor = v_color * texture2D(u_texture, v_texCoords) * vec4(0.0, 0.0, 2.0, 1);\n" //
			+ "}";

		ShaderProgram shader = new ShaderProgram(vertexShader, fragmentShader);
		if (shader.isCompiled() == false) throw new IllegalArgumentException("couldn't compile shader: " + shader.getLog());
		Console.debug("compiled custom shader");
		
		return shader;
		
	}

	protected void selectRoom(int rx, int ry) {
		Room oldSelection = currentRoom;
		currentRoom = getWorld().roomMap.get(rx, ry);		
		if (currentRoom != null && currentRoom != oldSelection) {
			roomInspector.setRoom(currentRoom);
			roomInspector.setVisible(true);
		} else {
			if (currentRoom == oldSelection) {
				// deselect
				currentRoom = null;
			}
			roomInspector.setVisible(false);
		}
	}
	public void spawnActor(float x, float y) {
		// [@temp just adds an entity for now]
		TextureRegion region = new TextureRegion(texture, 4 * 32, 5 * 32, 32, 32);
		Actor actor = new GameEntity(region);	
		actor.setBounds(x, y, 32, 32);
		actor.setOrigin(16, 30);
		entities.addActor(actor);		
	}
	
	public void update(float delta) {
		OrthographicCamera cam = (OrthographicCamera)stage.getCamera();
		float moveX = 0;
		float moveY = 0;
		float scrollSpeed = SCROLL_SPEED * delta;
		if (Gdx.input.isKeyPressed(Input.Keys.SHIFT_LEFT)) {
			scrollSpeed *= SCROLL_FAST_MULTIPLIER;
		}
		if (Gdx.input.isKeyPressed(Input.Keys.A)) {
			moveX -= scrollSpeed * cam.zoom;
		} 
		if (Gdx.input.isKeyPressed(Input.Keys.D)) {
			moveX += scrollSpeed * cam.zoom;
		} 
		if (Gdx.input.isKeyPressed(Input.Keys.W)) {
			moveY += scrollSpeed * cam.zoom;
		} 
		if (Gdx.input.isKeyPressed(Input.Keys.S)) {
			moveY -= scrollSpeed * cam.zoom;
		} 		
		cam.translate(moveX, moveY);

		Vector2 pos = stage.stageToScreenCoordinates(new Vector2(0, 0));
		boolean fixed = false;
		
		// [@todo constrain screen scrolling maybe]
//		Console.debug("%s", pos);
//		if (pos.x > 0) { pos.x = -pos.x; fixed = true; }
//		if (pos.y > 0) { pos.y = -pos.y; fixed = true; }
//		if (fixed) {
//			cam.translate(stage.screenToStageCoordinates(pos));
//		}
//		Console.debug("  %s", cam.position);
		getWorld().tick(delta);
		
		
		stage.act(delta);
		uiStage.act(delta);
	}
	
	/* (non-Javadoc)
	 * @see com.mutantamoeba.ld25.screens.BasicScreen#dispose()
	 */
	@Override
	public void dispose() {
		texture.dispose();
		super.dispose();
	}
	
	/* (non-Javadoc)
	 * @see com.mutantamoeba.ld25.screens.BasicScreen#scrolled(int)
	 */
	@Override
	public boolean scrolled(int amount) {
//		Console.debug("SCROLLED:%d", amount);
		OrthographicCamera cam = (OrthographicCamera)stage.getCamera(); 
		cam.zoom += amount / 10.0f;
		float minZoom = 0.5f;
		float maxZoom = 10;
		if (cam.zoom < minZoom) {
			cam.zoom = minZoom;
		} else if (cam.zoom > maxZoom) {
			cam.zoom = maxZoom;
		}
		return super.scrolled(amount);
	}
	
	/* (non-Javadoc)
	 * @see com.mutantamoeba.ld25.screens.BasicScreen#keyTyped(char)
	 */
	@Override
	public boolean keyTyped(char character) {
		switch (character) {
		case 'l':
				LD25.DEBUG_MODE = false;
				return true;
		}
		return super.keyTyped(character);
	}

	/**
	 * @param world the world to set
	 */
	public void setWorld(GameWorld world) {
		this.world = world;
	}

	/**
	 * @return the world
	 */
	public GameWorld getWorld() {
		return world;
	}

	/* (non-Javadoc)
	 * @see com.mutantamoeba.ld25.screens.BasicScreen#resize(int, int)
	 */
	@Override
	public void resize(int width, int height) {
		super.resize(width, height);
		if (sidePanel != null) {
			sidePanel.setBounds(0, 0, SIDEPANEL_WIDTH, uiStage.getHeight());
		}
		
	}

	/* (non-Javadoc)
	 * @see com.mutantamoeba.ld25.engine.BasicInputProcessor#keyUp(int)
	 */
	@Override
	public boolean keyUp(int keycode) {
		if (keycode == Input.Keys.F11){
			Console.debug("fullscreen toggle");
			toggleFullscreen();
		}
		return super.keyUp(keycode);
	}

	/* (non-Javadoc)
	 * @see com.mutantamoeba.ld25.screens.BasicScreen#render(float)
	 */
	@Override
	public void render(float delta) {		
		super.render(delta);
	    particleEffect.draw(stage.getSpriteBatch(), delta);
	}		
}
package com.mutantamoeba.ld25.screens;

import com.badlogic.gdx.Game;
import com.badlogic.gdx.Gdx;

import static com.badlogic.gdx.scenes.scene2d.actions.Actions.*;
import com.badlogic.gdx.scenes.scene2d.InputEvent;
import com.badlogic.gdx.scenes.scene2d.utils.ClickListener;
import com.mutantamoeba.ld25.LD25;
import com.mutantamoeba.ld25.actors.SimpleTextButton;
import com.mutantamoeba.ld25.engine.Console;

public class MainMenuScreen extends BasicScreen {
	public MainMenuScreen(Game game) {
		super(game);
		
		
		SimpleTextButton butt = new SimpleTextButton(this, "> press anything to start <");
		stage.addActor(butt);
		butt.setPosition((Gdx.graphics.getWidth()-butt.getWidth()) / 2, (Gdx.graphics.getHeight()-butt.getHeight()) / 2);
		
		butt.addListener(new ClickListener() {

			/* (non-Javadoc)
			 * @see com.badlogic.gdx.scenes.scene2d.utils.ClickListener#clicked(com.badlogic.gdx.scenes.scene2d.InputEvent, float, float)
			 */
			@Override
			public void clicked(InputEvent event, float x, float y) {
				Console.debug("%s clicked at %f, %f", this, x, y);
				super.clicked(event, x, y);
				LD25.instance().setScreen(new GameScreen(LD25.instance()));
			}
			
			
		});
	}
	
	/* (non-Javadoc)
	 * @see com.mutantamoeba.ld25.engine.BasicInputProcessor#keyDown(int)
	 */
	@Override
	public boolean keyDown(int keycode) {
		LD25.instance().setScreen(new GameScreen(LD25.instance()));
		
		return super.keyDown(keycode);
	}
}
package com.mutantamoeba.ld25.screens;

import com.badlogic.gdx.graphics.g2d.BitmapFont;
import com.badlogic.gdx.graphics.g2d.NinePatch;
import com.badlogic.gdx.graphics.g2d.SpriteBatch;
import com.badlogic.gdx.scenes.scene2d.Group;
import com.badlogic.gdx.scenes.scene2d.InputEvent;
import com.badlogic.gdx.scenes.scene2d.utils.DragListener;
import com.mutantamoeba.ld25.Room;

public class RoomInspector extends Group {
	Room room;
	NinePatch ninePatch;
	BitmapFont font;
	RoomInspector(NinePatch ninePatch, BitmapFont bitmapFont) {
		this.ninePatch = ninePatch;
		this.font = bitmapFont;
		setVisible(false);
		addListener(new DragListener() {
			float xOffset=0, yOffset=0;
			/* (non-Javadoc)
			 * @see com.badlogic.gdx.scenes.scene2d.utils.DragListener#drag(com.badlogic.gdx.scenes.scene2d.InputEvent, float, float, int)
			 */
			@Override
			public void drag(InputEvent event, float x, float y, int pointer) {
				setPosition(x - xOffset, y - yOffset);
				super.drag(event, x, y, pointer);				
			}

			/* (non-Javadoc)
			 * @see com.badlogic.gdx.scenes.scene2d.utils.DragListener#dragStart(com.badlogic.gdx.scenes.scene2d.InputEvent, float, float, int)
			 */
			@Override
			public void dragStart(InputEvent event, float x, float y,
					int pointer) {
				xOffset = x - getX();
				yOffset = y - getY();
				super.dragStart(event, x, y, pointer);
			}

			/* (non-Javadoc)
			 * @see com.badlogic.gdx.scenes.scene2d.utils.DragListener#dragStop(com.badlogic.gdx.scenes.scene2d.InputEvent, float, float, int)
			 */
			@Override
			public void dragStop(InputEvent event, float x, float y, int pointer) {
				// TODO Auto-generated method stub
				super.dragStop(event, x, y, pointer);
			}
			
		});
	}
	/**
	 * @return the room
	 */
	public Room getRoom() {
		return room;
	}

	/**
	 * @param room the room to set
	 */
	public void setRoom(Room room) {
		this.room = room;
	}
	
	/* (non-Javadoc)
	 * @see com.badlogic.gdx.scenes.scene2d.Group#draw(com.badlogic.gdx.graphics.g2d.SpriteBatch, float)
	 */
	@Override
	public void draw(SpriteBatch batch, float parentAlpha) {
		if (isVisible() && room != null) {
			
			this.ninePatch.draw(batch, getX(), getY(), getWidth(), getHeight());
			String infoString = room.infoString();
			float height = font.getMultiLineBounds(infoString).height;
			font.drawMultiLine(batch, infoString, getX() + 30, getY() + getHeight() - 25);
		}
		super.draw(batch, parentAlpha);
	}
	
}
package com.mutantamoeba.ld25.screens;

import java.util.Random;

import com.badlogic.gdx.Game;
import com.badlogic.gdx.Gdx;
import com.badlogic.gdx.graphics.Color;
import com.badlogic.gdx.graphics.OrthographicCamera;
import com.badlogic.gdx.graphics.g2d.SpriteBatch;
import com.badlogic.gdx.scenes.scene2d.Actor;
import com.badlogic.gdx.scenes.scene2d.Event;
import com.mutantamoeba.ld25.engine.Console;

public class TestScreen extends BasicScreen {
	static Random rand = new Random();	
	public TestScreen(Game game) {
		super(game);
		
	}

	public class TestActor extends Actor {
		private float angle;
		private Color color;
		private boolean noMove = false;
		private int UID = rand.nextInt();
		public TestActor() {
			super();			
			angle = rand.nextInt(200) - 100;
			color = new Color(rand.nextFloat(), rand.nextFloat(), rand.nextFloat(), 1);
			this.setSize(40f, 30f);
			
		}
		@Override
		public void draw(SpriteBatch batch, float parentAlpha) {
			// TODO Auto-generated method stub
			super.draw(batch, parentAlpha);
			getFont().setColor(color);
			getFont().draw(getStage().getSpriteBatch(), "hello", getX(), getY());						
		}

		@Override
		public void act(float delta) {
			// TODO Auto-generated method stub
			super.act(delta);
			updatePosition();
			angle += delta * 5.0f;
		}
		
		public void updatePosition() {
			this.setPosition(Gdx.graphics.getWidth() / 2.0f + 200f * ((float)Math.sin(angle / 7f) + (float)Math.cos(angle / 13f)), 
					Gdx.graphics.getHeight() / 2.0f + 100f * ((float)Math.cos(angle / 3f) + (float)Math.sin(angle / 17f)));

		}

		@Override
		public boolean fire(Event event) {
			// TODO Auto-generated method stub
//			Console.debug("%s fire:%s", this, event);
			return super.fire(event);
			
		}

		@Override
		public boolean notify(Event event, boolean capture) {
			// TODO Auto-generated method stub			
//			Console.debug("%s notify:%s", this, event);							
			return super.notify(event, capture);
		}

		@Override
		public Actor hit(float x, float y, boolean touchable) {
			// TODO Auto-generated method stub
//			Console.debug("hit:%f, %f, %s", x, y, touchable ? "true" : "false");							
			return super.hit(x, y, touchable);
		}	
		
		@Override
		public String toString() {
			return String.format("TestActor[%d]", UID);
		}
	}
	
	@Override
	public void resize(int width, int height) {
		super.resize(width, height);
		for (int i=0;i<50;i++) 
			getStage().addActor(new TestActor());
	}

	@Override
	public boolean touchDown(int x, int y, int pointer, int button) {
		Actor hit = stage.hit(x, y, true);
		Console.debug("touchdown");
		if (hit == null) return false;
		Console.debug("hit actor (%s) at %d,%d", hit, x, y);
		return true;
	}
	
	/* (non-Javadoc)
	 * @see com.mutantamoeba.ld25.engine.BasicInputProcessor#scrolled(int)
	 */
	@Override
	public boolean scrolled(int amount) {
		Console.debug("SCROLLED:%d", amount);
		((OrthographicCamera)stage.getCamera()).zoom += amount / 10.0f;
		return super.scrolled(amount);
	}

}
package com.mutantamoeba.ld25.tilemap;

import com.badlogic.gdx.graphics.Texture;
import com.badlogic.gdx.utils.Array;
import com.badlogic.gdx.utils.ObjectMap;
import com.mutantamoeba.ld25.engine.Console;
import com.mutantamoeba.ld25.utils.RandomNumbers;

public class GameTileset {
	public Texture texture;
	int		tileSize;
	ObjectMap<String, Integer>	setNameToIndex = new ObjectMap<String, Integer>();
	Array<TileSubset> tileSubsets = new Array<TileSubset>();
	
	public GameTileset(Texture texture, int tileSize) {
		 this.texture = texture;
		 this.tileSize = tileSize;
	}

	public TileSubset addSubset(String name, TileSubset.Type type, int ...tileIndices) {
		TileSubset set;
		switch (type) {
		case SINGLE:
			set = TileSubset.createSingle(tileIndices[0]);
			break;
		case MULTI:
			set = TileSubset.createMulti(tileIndices);
			break;
		case NINEPATCH:
			set = TileSubset.createNinePatch(tileIndices);
			break;
		default:
			Console.debug("definition of %s [%s] contains an unknown type: %s", name, tileIndices, type);
			return null;
		}
		
		int idx = tileSubsets.size;
		setNameToIndex.put(name, idx);
		tileSubsets.add(set);
		
		// [@temp DEBUGGING]
//		String listStr = "";
//		for (int i=0;i<tileIndices.length;i++) {
//			listStr += Integer.toString(tileIndices[i]);
//			if (i < tileIndices.length-1) {
//				listStr += ", ";
//			}
//		}
//
//		Console.debug("added tileset %s [%s] {%s}", name, type, listStr);
//		
		// END DEBUGGING
		
		return set;
	}

	/** Returns an actual tile index based on the position and id
	 * @param x tile map position
	 * @param y tile map position
	 * @param tileId the tile subset id
	 * @return tile index as specified by the subset
	 */
	public int getTileIndex(int x, int y, int tileId) {
		TileSubset subset = tileSubsets.get(tileId);
		switch (subset.type) {
		case SINGLE:
			return ((TileSubsetSingle)subset).tileIndex;
		case MULTI:
			int indices[] = ((TileSubsetMulti)subset).tileIndices; 
			int index = (int)((x+y) % indices.length);
			return indices[index];
		default:
			return 0;
		}
	}

	public int getId(String string) {
		if (setNameToIndex.containsKey(string)) {
			return setNameToIndex.get(string);
		}
		return -1;
	}

	public int[] getTileIndices(int tileId) {
		if (tileId == -1) return null;
		
		TileSubset subset = tileSubsets.get(tileId);
		switch (subset.type) {
		case MULTI:
			int indices[] = ((TileSubsetMulti)subset).tileIndices; 
			return indices;
		default:
			return null;
		}		
	}
}
package com.mutantamoeba.ld25.tilemap;

import com.mutantamoeba.ld25.GameWorld;

public class Tile {
	public static final int FLOOR_LAYER = 0;
	public static final int HAZARD_LAYER = 1;
	public static final int WALL_LAYER = 2;
	
	public int layers[] = new int[TileMap.TOTAL_LAYERS];
	public Tile() {
		clear();
	}
	public Tile(int layers[]) {
		this();
		for (int i=0;i<TileMap.TOTAL_LAYERS && i < layers.length;i++) {
			this.layers[i] = layers[i];
		}
	}
	public int getLayer(int layerNum) {
		if (layerNum < 0 || layerNum >= TileMap.TOTAL_LAYERS) {
			return -1;
		}
		return layers[layerNum];
	}
	public void setLayer(int layerNum, int tileIndex) {
		if (layerNum < 0 || layerNum >= TileMap.TOTAL_LAYERS) {
			return;
		}
		layers[layerNum] = tileIndex;
	}
	public void clear() {
		for (int i=0;i<TileMap.TOTAL_LAYERS;i++) {
			layers[i] = -1;
		}
		layers[0] = GameWorld.instance().gameScreen().gameTiles.getTileIndex(0, 0, GameWorld.instance().gameScreen().gameTiles.getId("blank"));
	}
}
package com.mutantamoeba.ld25.tilemap;

import com.mutantamoeba.ld25.GameWorld;
import com.mutantamoeba.ld25.utils.ParameterMap;


/** The raw tile map (for rendering only)
 * @author keili
 *
 */
public class TileMap extends ParameterMap<Tile> {
	public static final int TOTAL_LAYERS = 4;
	public static Tile empty = new Tile();
	private GameWorld world;
	
	public TileMap(GameWorld world, int w, int h) {
		super("tiles", w, h, empty);
		if (empty.layers[0] == -1) {
			empty.layers[0] = world.gameScreen().gameTiles.getTileIndex(0, 0, world.gameScreen().gameTiles.getId("blank"));
		}
		this.world = world;
	}

}
package com.mutantamoeba.ld25.tilemap;

import com.badlogic.gdx.Gdx;
import com.badlogic.gdx.graphics.GL11;
import com.badlogic.gdx.graphics.g2d.SpriteBatch;
import com.badlogic.gdx.graphics.g2d.SpriteCache;
import com.badlogic.gdx.scenes.scene2d.Actor;
import com.mutantamoeba.ld25.GameWorld;
import com.mutantamoeba.ld25.engine.Console;
import com.mutantamoeba.ld25.screens.GameScreen;

public class TileRenderer extends Actor {
	GameWorld world;
	TileMap tileMap;
	GameTileset tileSet;
	SpriteCache cache;
	int cacheID;
	int textureTileWidth, textureTileHeight;

	public TileRenderer(GameWorld world, GameTileset tileSet) {
		this.world = world;
		tileMap = world.tileMap;
		this.tileSet = tileSet;
		textureTileWidth = tileSet.texture.getWidth() / GameScreen.TILE_SIZE;
		textureTileHeight = tileSet.texture.getHeight() / GameScreen.TILE_SIZE;
		
		// [@note this needs its own shader, or we need to render to texture]
		this.cache = new SpriteCache(this.world.tileMap._area
				* this.world.tileMap.TOTAL_LAYERS, true);
	}

	public void updateFromMap() {
		cache.clear();
		cache.beginCache();
		
		for (int layer = 0; layer < tileMap.TOTAL_LAYERS; layer++) {
			for (int y = 0, offs = 0; y < tileMap._h; y++) {
				int tileY = y * (GameScreen.TILE_SIZE);
				for (int x = 0; x < tileMap._w; x++, offs++) {
					int tileX = x * (GameScreen.TILE_SIZE);
					Tile t = tileMap.get(offs);

//					int tileId = t.getLayer(layer);
//					if (tileId == -1) {
//						continue;
//					}
//					int tileIndex = tileSet.getTileIndex(x, y, tileId); 
//					Console.debug("tileId:%d, tileIndex:%d", tileId, tileIndex);
					
					int tileIndex = t.getLayer(layer);
					if (tileIndex == -1) {
						continue;
					}
					int texX = tileIndex % textureTileWidth;
					int texY = tileIndex / textureTileWidth;
					cache.add(tileSet.texture, tileX, tileY, texX * GameScreen.TILE_SIZE, texY
							* GameScreen.TILE_SIZE, GameScreen.TILE_SIZE, GameScreen.TILE_SIZE);
				}
			}
		}
		cacheID = cache.endCache();
	}
	
	/* (non-Javadoc)
	 * @see com.badlogic.gdx.scenes.scene2d.Actor#draw(com.badlogic.gdx.graphics.g2d.SpriteBatch, float)
	 */
	@Override
	public void draw(SpriteBatch batch, float parentAlpha) {
		cache.setProjectionMatrix(batch.getProjectionMatrix());
		
//		batch.enableBlending();
//		batch.setBlendFunction(GL11.GL_SRC_ALPHA, GL11.GL_ONE_MINUS_SRC_ALPHA);
		
		cache.begin();
		Gdx.gl.glEnable(GL11.GL_BLEND);
		Gdx.gl.glBlendFunc(GL11.GL_SRC_ALPHA, GL11.GL_ONE_MINUS_SRC_ALPHA);
		cache.draw(cacheID);			
		Gdx.gl.glDisable(GL11.GL_BLEND);
//		batch.disableBlending();
		cache.end();
//		super.draw(batch, parentAlpha);
	}	
}
package com.mutantamoeba.ld25.tilemap;

public class TileSubset {
	public enum Type {
		SINGLE,
		MULTI,
		NINEPATCH
	}
	public Type type;
	public TileSubset(Type type) {
		this.type = type;
	}	
	public static TileSubsetSingle createSingle(int idx) {
		return new TileSubsetSingle(idx);
	}
	public static TileSubsetMulti createMulti(int indices[]) {
		return new TileSubsetMulti(indices);
	}
	public static TileSubsetNinePatch createNinePatch(int indices[]) {
		return new TileSubsetNinePatch(indices);
	}
	public String toString() {
		switch (type) {
		case SINGLE: return "TileSubset.SINGLE";
		case MULTI: return "TileSubset.MULTI";
		case NINEPATCH: return "TileSubset.NINEPATCH";
		}
		return "TileSubset";
	}
	
}
package com.mutantamoeba.ld25.tilemap;

import com.mutantamoeba.ld25.tilemap.TileSubset.Type;

public class TileSubsetMulti extends TileSubset {
	public int tileIndices[];
	public TileSubsetMulti(int tileIndices[]) {
		super(Type.MULTI);
		this.tileIndices = tileIndices;
	}
}package com.mutantamoeba.ld25.tilemap;

public class TileSubsetNinePatch extends TileSubsetMulti {

	public TileSubsetNinePatch(int[] tileIndices) {
		super(tileIndices);
		
	}

}
package com.mutantamoeba.ld25.tilemap;

import com.mutantamoeba.ld25.tilemap.TileSubset.Type;

public class TileSubsetSingle extends TileSubset {
	public int tileIndex;

	public TileSubsetSingle(int idx) {
		super(Type.SINGLE);
		tileIndex = idx;
	}
}
/**
 * 
 */
package com.mutantamoeba.ld25;

import java.util.Random;

import com.badlogic.gdx.Game;
import com.badlogic.gdx.Gdx;
import com.badlogic.gdx.Input;
import com.badlogic.gdx.graphics.GL10;
import com.badlogic.gdx.graphics.GL11;
import com.badlogic.gdx.graphics.OrthographicCamera;
import com.badlogic.gdx.graphics.Texture;
import com.badlogic.gdx.graphics.Texture.TextureFilter;
import com.badlogic.gdx.graphics.Texture.TextureWrap;
import com.badlogic.gdx.graphics.g2d.BitmapFont;
import com.badlogic.gdx.graphics.g2d.SpriteBatch;
import com.badlogic.gdx.graphics.g2d.SpriteCache;
import com.badlogic.gdx.math.Vector2;
import com.badlogic.gdx.scenes.scene2d.Actor;
import com.badlogic.gdx.scenes.scene2d.Event;
import com.badlogic.gdx.scenes.scene2d.InputEvent;
import com.badlogic.gdx.scenes.scene2d.Stage;
import com.badlogic.gdx.scenes.scene2d.utils.ClickListener;
import com.badlogic.gdx.scenes.scene2d.utils.DragListener;
import com.mutantamoeba.ld25.engine.Console;
import com.mutantamoeba.ld25.screens.BasicScreen;

/** The main game screen
 * @author keili
 *
 */
public class TileTestScreen extends BasicScreen {
	SimpleTileMap tileMap;
	static Random rand = new Random();
	Texture texture;
	boolean showFPS = true;
	Stage uiStage;

	public class SimpleTileMap extends Actor {
		static final int TOTAL_LAYERS = 2;
		Texture texture;
		SpriteCache cache;
		int w, h, area;
		int textureTileWidth, textureTileHeight;
		int maxTileIndex;
		int tileSize;
		int theMap[][];
		int cacheID = -1;
		SimpleTileMap(int w, int h, Texture texture) {
			super();
			this.tileSize = 32;
			setSize(w * this.tileSize, h * this.tileSize);
			addListener(new DragListener() {

				/* (non-Javadoc)
				 * @see com.badlogic.gdx.scenes.scene2d.utils.DragListener#drag(com.badlogic.gdx.scenes.scene2d.InputEvent, float, float, int)
				 */
				@Override
				public void drag(InputEvent event, float x, float y, int pointer) {
					beginEdit();
					setTile(x, y, 0, 24);
					endEdit();
					super.drag(event, x, y, pointer);
				}				
			});
			addListener(new ClickListener() {

				/* (non-Javadoc)
				 * @see com.badlogic.gdx.scenes.scene2d.utils.ClickListener#clicked(com.badlogic.gdx.scenes.scene2d.InputEvent, float, float)
				 */
				@Override
				public void clicked(InputEvent event, float x, float y) {
					beginEdit();
					setTile(x, y, 0, 24);
					endEdit();
					super.clicked(event, x, y);
				}
				
			});
			this.w = w;
			this.h = h;
			this.area = this.w * this.h;
			this.theMap = new int[this.area][TOTAL_LAYERS];
			for (int i=0;i<this.area;i++) {
				for (int j=0;j<TOTAL_LAYERS;j++) {
					theMap[i][j] = -1;
				}
			}
			this.texture = texture;
			this.textureTileWidth = this.texture.getWidth() / this.tileSize;
			this.textureTileHeight = this.texture.getHeight() / this.tileSize;
			this.maxTileIndex = this.textureTileWidth * this.textureTileHeight;
			this.cache = new SpriteCache(this.area * TOTAL_LAYERS, true);
			Console.debug("constructed SimpleTileMap:");
			Console.debug("  tiles: %dx%d (area:%d)", this.w, this.h, this.area);
			Console.debug("  texture tile size: %d x %d", this.textureTileWidth, this.textureTileHeight);
			Console.debug("  tileSize: %d", tileSize);
			
		}
		/* (non-Javadoc)
		 * @see com.badlogic.gdx.scenes.scene2d.Actor#draw(com.badlogic.gdx.graphics.g2d.SpriteBatch, float)
		 */
		@Override
		public void draw(SpriteBatch batch, float parentAlpha) {
			cache.setProjectionMatrix(batch.getProjectionMatrix());
//			batch.enableBlending();
//			batch.setBlendFunction(GL11.GL_SRC_ALPHA, GL11.GL_ONE_MINUS_SRC_ALPHA);
			
			cache.begin();
			Gdx.gl.glEnable(GL11.GL_BLEND);
			Gdx.gl.glBlendFunc(GL11.GL_SRC_ALPHA, GL11.GL_ONE_MINUS_SRC_ALPHA);
			cache.draw(cacheID);			
			Gdx.gl.glDisable(GL11.GL_BLEND);
//			batch.disableBlending();
			cache.end();
//			super.draw(batch, parentAlpha);
		}

		/* (non-Javadoc)
		 * @see com.badlogic.gdx.scenes.scene2d.Actor#act(float)
		 */
		@Override
		public void act(float delta) {
			// TODO Auto-generated method stub
			super.act(delta);
		}
		
		public void beginEdit() {
			cache.clear();
			cache.beginCache();			
		}
		public void endEdit() {
			for (int layer = 0; layer < TOTAL_LAYERS; layer++) {
				for (int y=0, offs=0;y<h;y++) {
					int tileY = y * (tileSize);
					for (int x=0;x<w;x++, offs++) {
						int tileX = x * (tileSize);
						int tileIndex = theMap[offs][layer];
						if (tileIndex == -1) {
							continue;
						}
						int texX = tileIndex % textureTileWidth;
						int texY = tileIndex / textureTileWidth;					
						cache.add(texture, tileX, tileY, texX * tileSize, texY * tileSize, tileSize, tileSize);
					}
				}
			}
			cacheID = cache.endCache();
			
		}
		public void setTile(int x, int y, int layer, int tileIndex) {
			if (x < 0 || y < 0 || x >= w || y >= h) return;
			theMap[y * w + x][layer] = tileIndex;
		}
		public void setTile(float x, float y, int layer, int tileIndex) {
			Vector2 pos = new Vector2(x, y);
			pos = this.stageToLocalCoordinates(pos);
			pos.div(tileSize);
			Console.debug("Setting %f, %f [layer:%d] to %d", pos.x, pos.y, layer, tileIndex);

			setTile((int)pos.x, (int)pos.y, layer, tileIndex);
		}
	}
	public TileTestScreen(Game game) {
		super(game);
		
//		texture = new Texture("data/tileTest.png");
		texture = new Texture("data/tiles.png");
		texture.setFilter(TextureFilter.Nearest, TextureFilter.Nearest);
		texture.setWrap(TextureWrap.ClampToEdge, TextureWrap.ClampToEdge);
				 	
		tileMap = new SimpleTileMap(16, 32, texture);
		int wallTiles[] = new int[] { 0, 1, 2, 8, 9, 10, 16, 17, 18 };
		tileMap.beginEdit();
		for (int i=0;i<tileMap.area;i++) {
			tileMap.theMap[i][0] = 27;
			if (rand.nextInt(100) < 10) {
				int tx = i % tileMap.textureTileWidth;
				int ty = i / tileMap.textureTileWidth;
				int wx = tx % 3;
				int wy = ty % 3;
				tileMap.theMap[i][1] = wallTiles[wy * 3 + wx];
			} 
		}
		tileMap.endEdit();
		stage.addActor(tileMap);
		uiStage = new Stage( Gdx.graphics.getWidth(), Gdx.graphics.getHeight(), true);
		uiStage.getSpriteBatch().getTransformMatrix().scale(1, -1, 1);
		Actor fpsCounter = new Actor() {
			int lastFPS;
			/* (non-Javadoc)
			 * @see com.badlogic.gdx.scenes.scene2d.Actor#draw(com.badlogic.gdx.graphics.g2d.SpriteBatch, float)
			 */
			@Override
			public void draw(SpriteBatch batch, float parentAlpha) {
				// TODO Auto-generated method stub
				BitmapFont fnt = getFont();				
				
				fnt.draw(batch, 
						String.format("FPS:%d", Gdx.graphics.getFramesPerSecond()), getX(), getY());
				this.setSize(30, 10);
			}

			/* (non-Javadoc)
			 * @see com.badlogic.gdx.scenes.scene2d.Actor#act(float)
			 */
			@Override
			public void act(float delta) {
				// TODO Auto-generated method stub
				super.act(delta);
			}

			/* (non-Javadoc)
			 * @see com.badlogic.gdx.scenes.scene2d.Actor#fire(com.badlogic.gdx.scenes.scene2d.Event)
			 */
			@Override
			public boolean fire(Event event) {
				Console.debug("FPSCounter");
				if (event instanceof InputEvent && ((InputEvent)event).getType() == InputEvent.Type.touchDown) {
					Console.debug("FPS counter:%s", event);
				}
				return super.fire(event);
			}
			
			
		};
		fpsCounter.setPosition(10, 20);
		uiStage.addActor(fpsCounter);

	}
	/* (non-Javadoc)
	 * @see com.mutantamoeba.ld25.screens.BasicScreen#render(float)
	 */
	@Override
	public void render(float delta) {	
		OrthographicCamera cam = (OrthographicCamera)stage.getCamera();
		float moveX = 0;
		float moveY = 0;
		float scrollSpeed = 2;
		if (Gdx.input.isKeyPressed(Input.Keys.SHIFT_LEFT)) {
			scrollSpeed *= 3;
		}
		if (Gdx.input.isKeyPressed(Input.Keys.A)) {
			moveX -= scrollSpeed * cam.zoom;
		} 
		if (Gdx.input.isKeyPressed(Input.Keys.D)) {
			moveX += scrollSpeed * cam.zoom;
		} 
		if (Gdx.input.isKeyPressed(Input.Keys.W)) {
			moveY += scrollSpeed * cam.zoom;
		} 
		if (Gdx.input.isKeyPressed(Input.Keys.S)) {
			moveY -= scrollSpeed * cam.zoom;
		} 
		cam.translate(moveX, moveY);
		stage.act(delta);
		
		Gdx.gl.glClearColor(1,0,1,1);
		Gdx.gl.glClear(GL10.GL_COLOR_BUFFER_BIT);
		
		stage.draw();
		
		uiStage.act(delta);
		uiStage.draw();
	}
	/* (non-Javadoc)
	 * @see com.mutantamoeba.ld25.screens.BasicScreen#dispose()
	 */
	@Override
	public void dispose() {
		texture.dispose();
		super.dispose();
	}
	/* (non-Javadoc)
	 * @see com.mutantamoeba.ld25.screens.BasicScreen#scrolled(int)
	 */
	@Override
	public boolean scrolled(int amount) {
//		Console.debug("SCROLLED:%d", amount);
		OrthographicCamera cam = (OrthographicCamera)stage.getCamera(); 
		cam.zoom += amount / 10.0f;
		float minZoom = 0.1f;
		float maxZoom = 10;
		if (cam.zoom < minZoom) {
			cam.zoom = minZoom;
		} else if (cam.zoom > maxZoom) {
			cam.zoom = maxZoom;
		}
		return super.scrolled(amount);
	}
	
	/* (non-Javadoc)
	 * @see com.mutantamoeba.ld25.engine.BasicInputProcessor#touchDown(int, int, int, int)
	 */
	@Override
	public  boolean touchDown(int x, int y, int pointer, int button) {
//		Console.debug("touchdown %d, %d", x, y);
		uiStage.touchDown(x, y, pointer, button);
		return super.touchDown(x, y, pointer, button);
	}


	/* (non-Javadoc)
	 * @see com.mutantamoeba.ld25.engine.BasicInputProcessor#touchUp(int, int, int, int)
	 */
	@Override
	public boolean touchUp(int x, int y, int pointer, int button) {
		uiStage.touchUp(x, y, pointer, button);
		return super.touchUp(x, y, pointer, button);
	}


	/* (non-Javadoc)
	 * @see com.mutantamoeba.ld25.engine.BasicInputProcessor#touchDragged(int, int, int)
	 */
	@Override
	public boolean touchDragged(int x, int y, int pointer) {
		Console.debug("dragged");
		uiStage.touchDragged(x, y, pointer);
		return stage.touchDragged(x, y, pointer);
	}	
}
package com.mutantamoeba.ld25.utils;

import com.badlogic.gdx.scenes.scene2d.Event;
import com.badlogic.gdx.scenes.scene2d.InputListener;
import com.mutantamoeba.ld25.engine.Console;

public class DebugListener extends InputListener {
	String label;
	public DebugListener(String label) {
		this.label = label;
	}
	DebugListener() {
		this("debugListener");
	}
	/* (non-Javadoc)
	 * @see com.badlogic.gdx.scenes.scene2d.InputListener#handle(com.badlogic.gdx.scenes.scene2d.Event)
	 */
	@Override
	public boolean handle(Event e) {
		Console.debug("%s:%s", this.label, e);
		return super.handle(e);
	}

}
package com.mutantamoeba.ld25.utils;

import java.io.File;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Properties;

public class MathUtils {
	static public final float PI = 3.141592653589f;
	static public float map(float in, float rMin, float rMax, float oMin, float oMax) {
		return ( (in-rMin) / (rMax-rMin)) * (oMax-oMin) + oMin;
	}
	static public float min(float a, float b) {
		return (a < b ? a : b);
	}
	static public float max(float a, float b) {
		return (a > b ? a : b);
	}
	static public float constrain(float a, float rMin, float rMax) {
		if (a < rMin)
			return rMin;
		else if (a > rMax)
			return rMax;
		return a;
	}
	static public float frac(float a) {
		return a - (int)a;
	}
	
	/* Just a port of well-known code (original source unknown, I found it via the Google Oracle)
	 * 
	 */
	static public double sqrt(final double a) {
	    final long x = Double.doubleToLongBits(a) >> 32;
	    double y = Double.longBitsToDouble((x + 1072632448) << 31);
	 
	    // repeat the following line for more precision
	    y = (y + a / y) * 0.5;
	    return y;
	}	
	
	/* Just a port of well-known code (original source unknown, I found it via the Google Oracle)
	 * 
	 */
	static public float inverseSqrt(double x) {
        final double xhalves = 0.5d * x;
        x = Double.longBitsToDouble(0x5FE6EB50C7B537AAl - (Double.doubleToRawLongBits(x) >> 1));
        
        // repeat the following line for more precision
        x = x * (1.5d - xhalves * x * x);
        return (float)x; 
	}
	
	/* Just a port of well-known code (original source unknown, I found it via the Google Oracle)
	 * 
	 */	
	static public float atan2(float y, float x) {
		float coeff_1 = PI / 4.0f;
		float coeff_2 = 3.0f * coeff_1;
		float abs_y = Math.abs(y);
		float angle;
		if (x >= 0) {
			float r = (x - abs_y) / (x + abs_y);
			angle = coeff_1 - coeff_1 * r;
		} else {
			float r = (x + abs_y) / (abs_y - x);
			angle = coeff_2 - coeff_1 * r;
		}
		return y < 0 ? -angle : angle;
	}
	
	static public double distance(float x1, float y1, float x2, float y2) {
		float x = x2 - x1;
		float y = y2 - y1;
		return sqrt(x*x + y*y);
	}
	static public float degrees(float rads) {
		return (rads * 180.0f) / PI;
	}
	static public float radians(float degs) {
		return (degs * PI) / 180.0f;
	}

	/* The angular distance between startAngle and targetAngle (avoids turns of > 180 degrees)
	 * @param start the source angle
	 * @param target the angle we wish to turn towards
	 */
	static public float dirDelta(float start, float target) {
	    float deltaDir = target - start;
	    
	    // constrain the delta so that our head doesn't spin the long way around
	    while (deltaDir < -PI)
	        deltaDir += 2*PI;
	    while (deltaDir > PI)
	        deltaDir -= 2*PI;
	        
	    return deltaDir;
	}

	/* performs a simple Hermite Blend
	 * 
	 */
	static public float hermiteBlend(float x, float y, float t) {
	    float bl = 3*(t*t) - 2*(t*t*t);
	    return x + (y-x)*bl;
	}

	/* turns a smooth value between 0..1 into a ridged (discrete) value in the same range
	 * @param x the input value (between 0 and 1)
	 * @param ridges how many discrete steps in the result
	 */
    public static float ridge(float x, int ridges) {
        // assumes the value is between 0 and 1
        int i = (int)(x * ridges);
        float stepSize = 1.0f / (float)ridges;        
        float val = i / (float)ridges;
        float frac =(( (x - val) ));

        frac -= 0.5;

        float dest;
        float boundary = 0.45f;
        if (frac < -boundary) {
            dest = val - stepSize;
            frac = map(frac, -0.5f, -boundary, 0, 1);
        } else if (frac > boundary) {
            dest = val + stepSize;
            frac = map(frac, boundary, 0.5f, 1, 0);
        } else {
            dest = val;
            frac = 1.0f;
        }
        val += (dest-val)*(1.0-frac);
        return val;
    }
    
    public static float ridgeFrac(float x, int ridges) {
        // assumes the value is between 0 and 1
        int i = (int)(x * ridges);
        float stepSize = 1.0f / (float)ridges;        
        float val = i / (float)ridges;
        float frac = x - val; 

        return constrain(frac, 0, 1);
    }    
    public static float lerp(float a, float b, float amnt) {
    	return a + (b-a)*amnt;
    }
}
package com.mutantamoeba.ld25.utils;


public class ParameterMap<ContentType> {
    String    _name;
    public final int       _w, _h, _area;
    Object    _map[];
    public ParameterMap(String name, int w, int h, ContentType defaultValue) {
        _w = w;
        _h = h;
        _area = w * h;
        _name = name;
        _map = new Object[_area];
        for (int i=0;i<_area;i++) {
            _map[i] = defaultValue;
        }
    }
    public ContentType get(int x, int y) {
        x = (int)MathUtils.constrain(x, 0, _w-1);
        y = (int)MathUtils.constrain(y, 0, _h-1);
        return (ContentType)_map[y*_w+x];
    }
    public ContentType get(int offs) {
        offs = (int)MathUtils.constrain(offs, 0, _area-1);
        return (ContentType)_map[offs];
    }
    public void set(int x, int y, ContentType v) {
        x = (int)MathUtils.constrain(x, 0, _w-1);
        y = (int)MathUtils.constrain(y, 0, _h-1);
        
        int ix = (int)x;
        int iy = (int)y;
        _map[iy*_w+ix] = v;      
    }
    public void set(int offs, ContentType v) {
        offs = (int)MathUtils.constrain(offs, 0, _area-1);
        _map[offs] = v;
    }    
}package com.mutantamoeba.ld25.utils;

import java.util.Random;

/**
 * @author keili
 *
 */
public class RandomNumbers {
	static public Random rand = new Random();
	
	// wrapping java.util.Random functions
	static public float nextFloat() { return rand.nextFloat(); }
	static public double nextGaussian() { return rand.nextGaussian(); }	
	static public int nextInt() { return rand.nextInt(); }
	static public int nextInt(int lim) { return rand.nextInt(lim); }
	static public boolean nextBoolean() { return rand.nextBoolean(); }	
	static public void setSeed(long seed) { rand.setSeed(seed); }
	
	/** chooses the index of a list of probabilities at random
	 * 
	 * @param chances a list of integer weights
	 * @return the index of the chosen weight
	 */
	static public int weightedRandom(int... chances) {
	    int total = 0;
	    for (Integer chance:chances) {
	        total += chance;
	    }
	    int val = nextInt(total);
	    
	    int accum = 0;
	    for (int i=0;i<chances.length;i++) {
	        accum += chances[i];
	        if (val < accum) {
	            return i;
	        }
	    }
	    return 0;
	}
	
	/** generates a pseudorandom number based on input coordinates
	 * can be used to seed the random number generator, or just raw
	 * @param x
	 * @param y
	 * @return a random long
	 */
	static public long locHash(int x, int y) {
	    return ((x * 0x1337) % 157931) * ((y * 319489) % 2696063) + 9876413;
//	    return (((x * 10011101 + y) % 53781811) * ((y * 253124999 + x) % 285646799) + 9876413) ^ (x * y * 285646799);    
	}
	
	static public float locFloat(int x, int y) {
		return (float)(locHash(x, y) / (double)Long.MAX_VALUE);
	}
	
}
package com.mutantamoeba.ld25.utils;

public abstract class Singleton<T> {
	T	_instance;
	public abstract T create();
	public T instance() {
		if (_instance == null) {
			_instance = create();
		}
		return _instance;
	}
}
package com.mutantamoeba.ld25.utils;

import java.io.File;
import java.util.Properties;
import java.util.Map.Entry;

public class StringUtils {
	static public String repeat(char c, int count) {
		String res = "";
		
		for (int i=0;i<count;i++) {
			res += c;
		}
		return res;
	}
	
	public static String join(Object o[], String sep) {
	    String res = "";
	    for (int i=0; i<o.length; i++) {
	        res += o[i].toString();
	        if (i < o.length-1) {
	            res += sep;
	        }
	    }
	    return res;
	}

	public static String join(Object o[], String sep, int spacing) {
	    String res = "";
	    for (int i=0; i<o.length; i++) {
	        res += String.format("%" + Integer.toString(spacing) + "s", o[i].toString());
	        if (i < o.length-1) {
	            res += sep;
	        }
	    }
	    return res;
	}
	public static String herePath(String fname) {
		Properties props = System.getProperties();
		
		for (Entry<Object, Object> prop:props.entrySet()) {
			String propName = (String)prop.getKey();
			Object propVal = prop.getValue();
			System.out.println(propName + ":" + propVal);
		}
//		String currentDir = new File(System.getProperty("user.dir"), fname).getAbsolutePath();
		File file = new File(System.getProperty("user.home"), "Library" + File.separator + 
																"Application Support" + File.separator + 
																"Mutant Amoeba/");
		file.mkdirs();
		file = new File(file.getAbsolutePath(), fname);
		String currentDir = file.getAbsolutePath();
		
		System.out.println(currentDir);
		return currentDir;
	}
}
package com.mutantamoeba.ld25;

import android.os.Bundle;

import com.badlogic.gdx.backends.android.AndroidApplication;
import com.badlogic.gdx.backends.android.AndroidApplicationConfiguration;

public class MainActivity extends AndroidApplication {
    @Override
    public void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        
        AndroidApplicationConfiguration cfg = new AndroidApplicationConfiguration();
        cfg.useGL20 = false;
        
        initialize(new LD25(), cfg);
    }
}package com.mutantamoeba.ld25;

import com.badlogic.gdx.Gdx;
import com.badlogic.gdx.backends.lwjgl.LwjglApplication;
import com.badlogic.gdx.backends.lwjgl.LwjglApplicationConfiguration;

public class Main {
	public static void main(String[] args) {
		LwjglApplicationConfiguration cfg = new LwjglApplicationConfiguration();
		cfg.title = "No, Mister Bond...";
		cfg.useGL20 = true;
		cfg.width = 1024;
		cfg.height = 768;	
		cfg.fullscreen = false;
		cfg.resizable = false;
//		cfg.vSyncEnabled = true;
//		cfg.useCPUSynch = true;
		new LwjglApplication(LD25.instance(), cfg);
	}
}
